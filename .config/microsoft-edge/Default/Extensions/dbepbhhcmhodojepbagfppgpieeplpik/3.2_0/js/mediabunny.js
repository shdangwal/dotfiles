export var mediabunny=(()=>{var e=Object.defineProperty,t=Object.defineProperties,r=Object.getOwnPropertyDescriptors,i=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,n=Object.prototype.propertyIsEnumerable,a=Math.pow,s=(t,r,i)=>r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[r]=i,c=(e,t)=>{for(var r in t||(t={}))o.call(t,r)&&s(e,r,t[r]);if(i)for(var r of i(t))n.call(t,r)&&s(e,r,t[r]);return e},d=(e,i)=>t(e,r(i)),u=(e,t)=>{var r={};for(var a in e)o.call(e,a)&&t.indexOf(a)<0&&(r[a]=e[a]);if(null!=e&&i)for(var a of i(e))t.indexOf(a)<0&&n.call(e,a)&&(r[a]=e[a]);return r},l=(e,t,r)=>new Promise(((i,o)=>{var n=e=>{try{s(r.next(e))}catch(e){o(e)}},a=e=>{try{s(r.throw(e))}catch(e){o(e)}},s=e=>e.done?i(e.value):Promise.resolve(e.value).then(n,a);s((r=r.apply(e,t)).next())}));function h(e){if(!e)throw new Error("Assertion failed.")}var m,f,p,w,g=e=>e&&e[e.length-1],b=e=>e>=0&&e<a(2,32),y=class e{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){var e;const t=Math.floor(this.pos/8),r=null!=(e=this.bytes[t])?e:0,i=7-(7&this.pos),o=(r&1<<i)>>i;return this.pos++,o}readBits(e){if(1===e)return this.readBit();let t=0;for(let r=0;r<e;r++)t<<=1,t|=this.readBit();return t}writeBits(e,t){const r=this.pos+e;for(let e=this.pos;e<r;e++){const i=Math.floor(e/8);let o=this.bytes[i];const n=7-(7&e);o&=~(1<<n),o|=(t&1<<r-e-1)>>r-e-1<<n,this.bytes[i]=o}this.pos=r}readAlignedByte(){var e;if(this.pos%8!=0)throw new Error("Bitstream is not byte-aligned.");const t=this.pos/8,r=null!=(e=this.bytes[t])?e:0;return this.pos+=8,r}skipBits(e){this.pos+=e}getBitsLeft(){return 8*this.bytes.length-this.pos}clone(){const t=new e(this.bytes);return t.pos=this.pos,t}},v=e=>{let t=0;for(;0===e.readBits(1)&&t<32;)t++;if(t>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<t)-1+e.readBits(t)},k=e=>{const t=v(e);return 0==(1&t)?-(t>>1):t+1>>1},T=e=>e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength),C=e=>e instanceof DataView?e:e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength),E=(new TextDecoder,new TextEncoder),S=e=>Object.fromEntries(Object.entries(e).map((([e,t])=>[t,e]))),x={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},_=(S(x),{bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pg:16,hlg:18}),B=(S(_),{rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9}),P=(S(B),e=>e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer||ArrayBuffer.isView(e)),M=class{constructor(){this.currentPromise=Promise.resolve()}acquire(){return l(this,null,(function*(){let e;const t=new Promise((t=>{e=t})),r=this.currentPromise;return this.currentPromise=t,yield r,e}))}},A=()=>{let e,t;return{promise:new Promise(((r,i)=>{e=r,t=i})),resolve:e,reject:t}},z=e=>{throw new Error(`Unexpected value: ${e}`)},I=(e,t,r,i)=>{r>>>=0,r&=16777215,i?(e.setUint8(t,255&r),e.setUint8(t+1,r>>>8&255),e.setUint8(t+2,r>>>16&255)):(e.setUint8(t,r>>>16&255),e.setUint8(t+1,r>>>8&255),e.setUint8(t+2,255&r))},O=(e,t,r)=>Math.max(t,Math.min(r,e)),F=/^[a-z]{3}$/,W=1e6*(1+Number.EPSILON),R=class{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}},V=function*(e){for(const t in e){const r=e[t];void 0!==r&&(yield{key:t,value:r})}},N=class{constructor(e,t){this.data=e,this.mimeType=t}},U=["avc","hevc","vp9","av1","vp8"],D=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],H=["aac","opus","mp3","vorbis","flac"],L=[...H,...D],$=["webvtt"],j=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],Q=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],q=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],K=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],X=(e,t,r,i)=>{var o,n,a,s;if("avc"===e){const e=100,n=Math.ceil(t/16)*Math.ceil(r/16),a=null!=(o=j.find((e=>n<=e.maxMacroblocks&&i<=e.maxBitrate)))?o:g(j),s=a?a.level:0;return`avc1.${e.toString(16).padStart(2,"0")}${"00"}${s.toString(16).padStart(2,"0")}`}if("hevc"===e){const e="",o=1,a="6",s=t*r,c=null!=(n=Q.find((e=>s<=e.maxPictureSize&&i<=e.maxBitrate)))?n:g(Q),d="B0";return`hev1.${e}${o}.${a}.${c.tier}${c.level}.${d}`}if("vp8"===e)return"vp8";if("vp9"===e){const e=t*r,o="08";return`vp09.${"00"}.${(null!=(a=q.find((t=>e<=t.maxPictureSize&&i<=t.maxBitrate)))?a:g(q)).level.toString().padStart(2,"0")}.${o}`}if("av1"===e){const e=0,o=t*r,n=null!=(s=K.find((e=>o<=e.maxPictureSize&&i<=e.maxBitrate)))?s:g(K),a="08";return`av01.${e}.${n.level.toString().padStart(2,"0")}${n.tier}.${a}`}throw new TypeError(`Unhandled codec '${e}'.`)},G=(e,t,r)=>{if("aac"===e)return t>=2&&r<=24e3?"mp4a.40.29":r<=24e3?"mp4a.40.5":"mp4a.40.2";if("mp3"===e)return"mp3";if("opus"===e)return"opus";if("vorbis"===e)return"vorbis";if("flac"===e)return"flac";if(D.includes(e))return e;throw new TypeError(`Unhandled codec '${e}'.`)},Y=/^pcm-([usf])(\d+)+(be)?$/,J=e=>{if(h(D.includes(e)),"ulaw"===e)return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if("alaw"===e)return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const t=Y.exec(e);let r;h(t),r="u"===t[1]?"unsigned":"s"===t[1]?"signed":"float";return{dataType:r,sampleSize:Number(t[2])/8,littleEndian:"be"!==t[3],silentValue:"pcm-u8"===e?a(2,7):0}},Z=e=>e.startsWith("avc1")||e.startsWith("avc3")?"avc":e.startsWith("hev1")||e.startsWith("hvc1")?"hevc":"vp8"===e?"vp8":e.startsWith("vp09")?"vp9":e.startsWith("av01")?"av1":e.startsWith("mp4a.40")||"mp4a.67"===e?"aac":"mp3"===e||"mp4a.69"===e||"mp4a.6B"===e||"mp4a.6b"===e?"mp3":"opus"===e?"opus":"vorbis"===e?"vorbis":"flac"===e?"flac":"ulaw"===e?"ulaw":"alaw"===e?"alaw":Y.test(e)?e:"webvtt"===e?"webvtt":null,ee=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],te=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,re=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,ie=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,oe=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,ne=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],ae=class{constructor(e){this.mutex=new M,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,t,r){t+=e.source._timestampOffset;let i=this.trackTimestampInfo.get(e);if(!i){if(!r)throw new Error("First frame must be a key frame.");i={maxTimestamp:t,maxTimestampBeforeLastKeyFrame:t},this.trackTimestampInfo.set(e,i)}if(t<0)throw new Error(`Timestamps must be non-negative (got ${t}s).`);if(r&&(i.maxTimestampBeforeLastKeyFrame=i.maxTimestamp),t<i.maxTimestampBeforeLastKeyFrame)throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous run (a run begins with a key frame and ends right before the next key frame). Got ${t}s, but highest timestamp is ${i.maxTimestampBeforeLastKeyFrame}s.`);return i.maxTimestamp=Math.max(i.maxTimestamp,t),t}},se=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,ce=e=>{const t=Math.floor(e/36e5),r=Math.floor(e%36e5/6e4),i=Math.floor(e%6e4/1e3),o=e%1e3;return t.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+":"+i.toString().padStart(2,"0")+"."+o.toString().padStart(3,"0")};(f=m||(m={}))[f.IDR=5]="IDR",f[f.SPS=7]="SPS",f[f.PPS=8]="PPS",f[f.SPS_EXT=13]="SPS_EXT",(w=p||(p={}))[w.RASL_N=8]="RASL_N",w[w.RASL_R=9]="RASL_R",w[w.BLA_W_LP=16]="BLA_W_LP",w[w.RSV_IRAP_VCL23=23]="RSV_IRAP_VCL23",w[w.VPS_NUT=32]="VPS_NUT",w[w.SPS_NUT=33]="SPS_NUT",w[w.PPS_NUT=34]="PPS_NUT",w[w.PREFIX_SEI_NUT=39]="PREFIX_SEI_NUT",w[w.SUFFIX_SEI_NUT=40]="SUFFIX_SEI_NUT";var de=e=>{const t=[];let r=0;for(;r<e.length;){let i=-1,o=0;for(let t=r;t<e.length-3;t++){if(0===e[t]&&0===e[t+1]&&1===e[t+2]){i=t,o=3;break}if(t<e.length-4&&0===e[t]&&0===e[t+1]&&0===e[t+2]&&1===e[t+3]){i=t,o=4;break}}if(-1===i)break;if(r>0&&i>r){const o=e.subarray(r,i);o.length>0&&t.push(o)}r=i+o}if(r<e.length){const i=e.subarray(r);i.length>0&&t.push(i)}return t},ue=e=>{const t=[],r=e.length;for(let i=0;i<r;i++)i+2<r&&0===e[i]&&0===e[i+1]&&3===e[i+2]?(t.push(0,0),i+=2):t.push(e[i]);return new Uint8Array(t)},le=e=>31&e[0],he=e=>e[0]>>1&63,me=(e,t)=>{const r=e.readBits(2),i=e.readBits(1),o=e.readBits(5);let n=0;for(let t=0;t<32;t++)n=n<<1|e.readBits(1);const a=new Uint8Array(6);for(let t=0;t<6;t++)a[t]=e.readBits(8);const s=e.readBits(8),c=[],d=[];for(let r=0;r<t;r++)c.push(e.readBits(1)),d.push(e.readBits(1));if(t>0)for(let r=t;r<8;r++)e.skipBits(2);for(let r=0;r<t;r++)c[r]&&e.skipBits(88),d[r]&&e.skipBits(8);return{general_profile_space:r,general_tier_flag:i,general_profile_idc:o,general_profile_compatibility_flags:n,general_constraint_indicator_flags:a,general_level_idc:s}},fe=e=>{for(let t=0;t<4;t++)for(let r=0;r<(3===t?2:6);r++){if(e.readBits(1)){const r=Math.min(64,1<<4+(t<<1));t>1&&k(e);for(let t=0;t<r;t++)k(e)}else v(e)}},pe=(e,t)=>{const r=[];for(let i=0;i<t;i++)r[i]=we(e,i,t,r)},we=(e,t,r,i)=>{var o;let n=0,a=0,s=0;if(0!==t&&(a=e.readBits(1)),a){if(t===r){s=t-(v(e)+1)}else s=t-1;e.readBits(1),v(e);const a=null!=(o=i[s])?o:0;for(let t=0;t<=a;t++){e.readBits(1)||e.readBits(1)}n=i[s]}else{const t=v(e),r=v(e);for(let r=0;r<t;r++)v(e),e.readBits(1);for(let t=0;t<r;t++)v(e),e.readBits(1);n=t+r}return n},ge=(e,t)=>{if(e.readBits(1)){255===e.readBits(8)&&(e.readBits(16),e.readBits(16))}if(e.readBits(1)&&e.readBits(1),e.readBits(1)&&(e.readBits(3),e.readBits(1),e.readBits(1)&&(e.readBits(8),e.readBits(8),e.readBits(8))),e.readBits(1)&&(v(e),v(e)),e.readBits(1),e.readBits(1),e.readBits(1),e.readBits(1)&&(v(e),v(e),v(e),v(e)),e.readBits(1)&&(e.readBits(32),e.readBits(32),e.readBits(1)&&v(e),e.readBits(1)&&be(e,!0,t)),e.readBits(1)){e.readBits(1),e.readBits(1),e.readBits(1);const t=v(e);return v(e),v(e),v(e),v(e),t}return 0},be=(e,t,r)=>{let i=!1,o=!1,n=!1;t&&(i=1===e.readBits(1),o=1===e.readBits(1),(i||o)&&(n=1===e.readBits(1),n&&(e.readBits(8),e.readBits(5),e.readBits(1),e.readBits(5)),e.readBits(4),e.readBits(4),n&&e.readBits(4),e.readBits(5),e.readBits(5),e.readBits(5)));for(let t=0;t<=r;t++){let t=!0;1===e.readBits(1)||(t=1===e.readBits(1));let r=!1;t?v(e):r=1===e.readBits(1);let a=1;if(!r){a=v(e)+1}i&&ye(e,a,n),o&&ye(e,a,n)}},ye=(e,t,r)=>{for(let i=0;i<t;i++)v(e),v(e),r&&(v(e),v(e)),e.readBits(1)},ve=class{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/a(2,32)),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let t=0;t<e.length;t++)this.helperView.setUint8(t%8,e.charCodeAt(t)),t%8==7&&this.writer.write(this.helper);e.length%8!=0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){var t,r;if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,null!=(t=e.size)?t:e.contents.byteLength+8),this.writer.write(e.contents);else{const t=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const t of e.children)t&&this.writeBox(t);const i=this.writer.getPos(),o=null!=(r=e.size)?r:i-t;this.writer.seek(t),this.writeBoxHeader(e,o),this.writer.seek(i)}}writeBoxHeader(e,t){this.writeU32(e.largeSize?1:t),this.writeAscii(e.type),e.largeSize&&this.writeU64(t)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const t=this.offsets.get(e);h(void 0!==t);const r=this.writer.getPos();this.writer.seek(t),this.writeBox(e),this.writer.seek(r)}measureBox(e){if(e.contents&&!e.children){return this.measureBoxHeader(e)+e.contents.byteLength}{let t=this.measureBoxHeader(e);if(e.contents&&(t+=e.contents.byteLength),e.children)for(const r of e.children)r&&(t+=this.measureBox(r));return t}}},ke=new Uint8Array(8),Te=new DataView(ke.buffer),Ce=e=>[(e%256+256)%256],Ee=e=>(Te.setUint16(0,e,!1),[ke[0],ke[1]]),Se=e=>(Te.setInt16(0,e,!1),[ke[0],ke[1]]),xe=e=>(Te.setUint32(0,e,!1),[ke[1],ke[2],ke[3]]),_e=e=>(Te.setUint32(0,e,!1),[ke[0],ke[1],ke[2],ke[3]]),Be=e=>(Te.setInt32(0,e,!1),[ke[0],ke[1],ke[2],ke[3]]),Pe=e=>(Te.setUint32(0,Math.floor(e/a(2,32)),!1),Te.setUint32(4,e,!1),[ke[0],ke[1],ke[2],ke[3],ke[4],ke[5],ke[6],ke[7]]),Me=e=>(Te.setInt16(0,a(2,8)*e,!1),[ke[0],ke[1]]),Ae=e=>(Te.setInt32(0,a(2,16)*e,!1),[ke[0],ke[1],ke[2],ke[3]]),ze=e=>(Te.setInt32(0,a(2,30)*e,!1),[ke[0],ke[1],ke[2],ke[3]]),Ie=(e,t)=>{const r=[];let i=e;do{let e=127&i;i>>=7,r.length>0&&(e|=128),r.push(e),void 0!==t&&t--}while(i>0||t);return r.reverse()},Oe=(e,t=!1)=>{const r=Array(e.length).fill(null).map(((t,r)=>e.charCodeAt(r)));return t&&r.push(0),r},Fe=e=>{let t=null;for(const r of e)(!t||r.timestamp>t.timestamp)&&(t=r);return t},We=e=>{const t=e*(Math.PI/180),r=Math.round(Math.cos(t)),i=Math.round(Math.sin(t));return[r,i,0,-i,r,0,0,0,1]},Re=We(0),Ve=e=>[Ae(e[0]),Ae(e[1]),ze(e[2]),Ae(e[3]),Ae(e[4]),ze(e[5]),Ae(e[6]),Ae(e[7]),ze(e[8])],Ne=(e,t,r)=>({type:e,contents:t&&new Uint8Array(t.flat(10)),children:r}),Ue=(e,t,r,i,o)=>Ne(e,[Ce(t),xe(r),null!=i?i:[]],o),De=e=>({type:"mdat",largeSize:e}),He=(e,t=!1)=>Ne("moov",void 0,[Le(e.creationTime,e.trackDatas),...e.trackDatas.map((t=>$e(t,e.creationTime))),t?Ct(e.trackDatas):null,Ft(e)]),Le=(e,t)=>{const r=ir(Math.max(0,...t.filter((e=>e.samples.length>0)).map((e=>{const t=Fe(e.samples);return t.timestamp+t.duration}))),tr),i=Math.max(0,...t.map((e=>e.track.id)))+1,o=!b(e)||!b(r),n=o?Pe:_e;return Ue("mvhd",+o,0,[n(e),n(e),_e(tr),n(r),Ae(1),Me(1),Array(10).fill(0),Ve(Re),Array(24).fill(0),_e(i)])},$e=(e,t)=>{const r=rr(e);return Ne("trak",void 0,[je(e,t),Qe(e,t),void 0!==r.name?Ne("udta",void 0,[Ne("name",[...E.encode(r.name)])]):null])},je=(e,t)=>{const r=Fe(e.samples),i=ir(r?r.timestamp+r.duration:0,tr),o=!b(t)||!b(i),n=o?Pe:_e;let a;if("video"===e.type){const t=e.track.metadata.rotation;a=We(null!=t?t:0)}else a=Re;return Ue("tkhd",+o,3,[n(t),n(t),_e(e.track.id),_e(0),n(i),Array(8).fill(0),Ee(0),Ee(e.track.id),Me("audio"===e.type?1:0),Ee(0),Ve(a),Ae("video"===e.type?e.info.width:0),Ae("video"===e.type?e.info.height:0)])},Qe=(e,t)=>Ne("mdia",void 0,[qe(e,t),Ge(!0,Ke[e.type],Xe[e.type]),Ye(e)]),qe=(e,t)=>{var r;const i=Fe(e.samples),o=ir(i?i.timestamp+i.duration:0,e.timescale),n=!b(t)||!b(o),a=n?Pe:_e;return Ue("mdhd",+n,0,[a(t),a(t),_e(e.timescale),a(o),Ee(qt(null!=(r=e.track.metadata.languageCode)?r:"und")),Ee(0)])},Ke={video:"vide",audio:"soun",subtitle:"text"},Xe={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},Ge=(e,t,r,i="\0\0\0\0")=>Ue("hdlr",0,0,[e?Oe("mhlr"):_e(0),Oe(t),Oe(i),_e(0),_e(0),Oe(r,!0)]),Ye=e=>Ne("minf",void 0,[Je[e.type](),Ze(),rt(e)]),Je={video:()=>Ue("vmhd",0,1,[Ee(0),Ee(0),Ee(0),Ee(0)]),audio:()=>Ue("smhd",0,0,[Ee(0),Ee(0)]),subtitle:()=>Ue("nmhd",0,0)},Ze=()=>Ne("dinf",void 0,[et()]),et=()=>Ue("dref",0,0,[_e(1)],[tt()]),tt=()=>Ue("url ",0,1),rt=e=>{const t=e.compositionTimeOffsetTable.length>1||e.compositionTimeOffsetTable.some((e=>0!==e.sampleCompositionTimeOffset));return Ne("stbl",void 0,[it(e),wt(e),t?kt(e):null,t?Tt(e):null,bt(e),yt(e),vt(e),gt(e)])},it=e=>{let t;if("video"===e.type)t=ot(Dt[e.track.source._codec],e);else if("audio"===e.type){const r=Lt(e.track.source._codec,e.muxer.isQuickTime);h(r),t=st(r,e)}else"subtitle"===e.type&&(t=pt(jt[e.track.source._codec],e));return h(t),Ue("stsd",0,0,[_e(1)],[t])},ot=(e,t)=>{return Ne(e,[Array(6).fill(0),Ee(1),Ee(0),Ee(0),Array(12).fill(0),Ee(t.info.width),Ee(t.info.height),_e(4718592),_e(4718592),_e(0),Ee(1),Array(32).fill(0),Ee(24),Se(65535)],[Ht[t.track.source._codec](t),(r=t.info.decoderConfig.colorSpace,r&&r.primaries&&r.transfer&&r.matrix&&void 0!==r.fullRange?nt(t):null)]);var r},nt=e=>Ne("colr",[Oe("nclx"),Ee(x[e.info.decoderConfig.colorSpace.primaries]),Ee(_[e.info.decoderConfig.colorSpace.transfer]),Ee(B[e.info.decoderConfig.colorSpace.matrix]),Ce((e.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),at=e=>{var t,r,i,o,n;if(!e.info.decoderConfig)return null;const a=e.info.decoderConfig,s=a.codec.split("."),c=Number(s[1]),d=Number(s[2]),u=(Number(s[3])<<4)+((s[4]?Number(s[4]):1)<<1)+(s[8]?Number(s[8]):Number(null!=(r=null==(t=a.colorSpace)?void 0:t.fullRange)?r:0)),l=s[5]?Number(s[5]):(null==(i=a.colorSpace)?void 0:i.primaries)?x[a.colorSpace.primaries]:2,h=s[6]?Number(s[6]):(null==(o=a.colorSpace)?void 0:o.transfer)?_[a.colorSpace.transfer]:2,m=s[7]?Number(s[7]):(null==(n=a.colorSpace)?void 0:n.matrix)?B[a.colorSpace.matrix]:2;return Ue("vpcC",1,0,[Ce(c),Ce(d),Ce(u),Ce(l),Ce(h),Ce(m),Ee(0)])},st=(e,t)=>{var r,i;let o,n=0,s=16;if(D.includes(t.track.source._codec)){const e=t.track.source._codec,{sampleSize:r}=J(e);s=8*r,s>16&&(n=1)}return o=0===n?[Array(6).fill(0),Ee(1),Ee(n),Ee(0),_e(0),Ee(t.info.numberOfChannels),Ee(s),Ee(0),Ee(0),Ee(t.info.sampleRate<a(2,16)?t.info.sampleRate:0),Ee(0)]:[Array(6).fill(0),Ee(1),Ee(n),Ee(0),_e(0),Ee(t.info.numberOfChannels),Ee(Math.min(s,16)),Ee(0),Ee(0),Ee(t.info.sampleRate<a(2,16)?t.info.sampleRate:0),Ee(0),_e(1),_e(s/8),_e(t.info.numberOfChannels*s/8),_e(2)],Ne(e,o,[null!=(i=null==(r=$t(t.track.source._codec,t.muxer.isQuickTime))?void 0:r(t))?i:null])},ct=e=>{let t;switch(e.track.source._codec){case"aac":t=64;break;case"mp3":t=107;break;case"vorbis":t=221;break;default:throw new Error(`Unhandled audio codec: ${e.track.source._codec}`)}let r=[...Ce(t),...Ce(21),...xe(0),..._e(0),..._e(0)];if(e.info.decoderConfig.description){const t=T(e.info.decoderConfig.description);r=[...r,...Ce(5),...Ie(t.byteLength),...t]}return r=[...Ee(1),...Ce(0),...Ce(4),...Ie(r.length),...r,...Ce(6),...Ce(1),...Ce(2)],r=[...Ce(3),...Ie(r.length),...r],Ue("esds",0,0,r)},dt=e=>Ne("wave",void 0,[ut(e),lt(e),Ne("\0\0\0\0")]),ut=e=>Ne("frma",[Oe(Lt(e.track.source._codec,e.muxer.isQuickTime))]),lt=e=>{const{littleEndian:t}=J(e.track.source._codec);return Ne("enda",[Ee(+t)])},ht=e=>{var t;let r=e.info.numberOfChannels,i=3840,o=e.info.sampleRate,n=0,a=0,s=new Uint8Array(0);const c=null==(t=e.info.decoderConfig)?void 0:t.description;if(c){h(c.byteLength>=18);const e=(e=>{const t=C(e),r=t.getUint8(9),i=t.getUint16(10,!0),o=t.getUint32(12,!0),n=t.getInt16(16,!0),a=t.getUint8(18);let s=null;return a&&(s=e.subarray(19,21+r)),{outputChannelCount:r,preSkip:i,inputSampleRate:o,outputGain:n,channelMappingFamily:a,channelMappingTable:s}})(T(c));r=e.outputChannelCount,i=e.preSkip,o=e.inputSampleRate,n=e.outputGain,a=e.channelMappingFamily,e.channelMappingTable&&(s=e.channelMappingTable)}return Ne("dOps",[Ce(0),Ce(r),Ee(i),_e(o),Se(n),Ce(a),...s])},mt=e=>{var t;const r=null==(t=e.info.decoderConfig)?void 0:t.description;h(r);const i=T(r);return Ue("dfLa",0,0,[...i.subarray(4)])},ft=e=>{const{littleEndian:t,sampleSize:r}=J(e.track.source._codec);return Ue("pcmC",0,0,[Ce(+t),Ce(8*r)])},pt=(e,t)=>Ne(e,[Array(6).fill(0),Ee(1)],[Qt[t.track.source._codec](t)]),wt=e=>Ue("stts",0,0,[_e(e.timeToSampleTable.length),e.timeToSampleTable.map((e=>[_e(e.sampleCount),_e(e.sampleDelta)]))]),gt=e=>{if(e.samples.every((e=>"key"===e.type)))return null;const t=[...e.samples.entries()].filter((([,e])=>"key"===e.type));return Ue("stss",0,0,[_e(t.length),t.map((([e])=>_e(e+1)))])},bt=e=>Ue("stsc",0,0,[_e(e.compactlyCodedChunkTable.length),e.compactlyCodedChunkTable.map((e=>[_e(e.firstChunk),_e(e.samplesPerChunk),_e(1)]))]),yt=e=>{if("audio"===e.type&&e.info.requiresPcmTransformation){const{sampleSize:t}=J(e.track.source._codec);return Ue("stsz",0,0,[_e(t*e.info.numberOfChannels),_e(e.samples.reduce(((t,r)=>t+ir(r.duration,e.timescale)),0))])}return Ue("stsz",0,0,[_e(0),_e(e.samples.length),e.samples.map((e=>_e(e.size)))])},vt=e=>e.finalizedChunks.length>0&&g(e.finalizedChunks).offset>=a(2,32)?Ue("co64",0,0,[_e(e.finalizedChunks.length),e.finalizedChunks.map((e=>Pe(e.offset)))]):Ue("stco",0,0,[_e(e.finalizedChunks.length),e.finalizedChunks.map((e=>_e(e.offset)))]),kt=e=>Ue("ctts",1,0,[_e(e.compositionTimeOffsetTable.length),e.compositionTimeOffsetTable.map((e=>[_e(e.sampleCount),Be(e.sampleCompositionTimeOffset)]))]),Tt=e=>{let t=1/0,r=-1/0,i=1/0,o=-1/0;h(e.compositionTimeOffsetTable.length>0),h(e.samples.length>0);for(let i=0;i<e.compositionTimeOffsetTable.length;i++){const o=e.compositionTimeOffsetTable[i];t=Math.min(t,o.sampleCompositionTimeOffset),r=Math.max(r,o.sampleCompositionTimeOffset)}for(let t=0;t<e.samples.length;t++){const r=e.samples[t];i=Math.min(i,ir(r.timestamp,e.timescale)),o=Math.max(o,ir(r.timestamp+r.duration,e.timescale))}const n=Math.max(-t,0);return o>=a(2,31)?null:Ue("cslg",0,0,[Be(n),Be(t),Be(r),Be(i),Be(o)])},Ct=e=>Ne("mvex",void 0,e.map(Et)),Et=e=>Ue("trex",0,0,[_e(e.track.id),_e(1),_e(0),_e(0),_e(0)]),St=(e,t)=>Ne("moof",void 0,[xt(e),...t.map(Bt)]),xt=e=>Ue("mfhd",0,0,[_e(e)]),_t=e=>{let t=0,r=0;const i="delta"===e.type;return r|=+i,t|=i?1:2,0|(t<<24|r<<16)},Bt=e=>Ne("traf",void 0,[Pt(e),Mt(e),At(e)]),Pt=e=>{var t;h(e.currentChunk);let r=0;r|=8,r|=16,r|=32,r|=131072;const i=null!=(t=e.currentChunk.samples[1])?t:e.currentChunk.samples[0],o={duration:i.timescaleUnitsToNextSample,size:i.size,flags:_t(i)};return Ue("tfhd",0,131128,[_e(e.track.id),_e(o.duration),_e(o.size),_e(o.flags)])},Mt=e=>(h(e.currentChunk),Ue("tfdt",1,0,[Pe(ir(e.currentChunk.startTimestamp,e.timescale))])),At=e=>{h(e.currentChunk);const t=e.currentChunk.samples.map((e=>e.timescaleUnitsToNextSample)),r=e.currentChunk.samples.map((e=>e.size)),i=e.currentChunk.samples.map(_t),o=e.currentChunk.samples.map((t=>ir(t.timestamp-t.decodeTimestamp,e.timescale))),n=new Set(t),a=new Set(r),s=new Set(i),c=new Set(o),d=2===s.size&&i[0]!==i[1],u=n.size>1,l=a.size>1,m=!d&&s.size>1,f=c.size>1||[...c].some((e=>0!==e));let p=0;return p|=1,p|=4*+d,p|=256*+u,p|=512*+l,p|=1024*+m,p|=2048*+f,Ue("trun",1,p,[_e(e.currentChunk.samples.length),_e(e.currentChunk.offset-e.currentChunk.moofOffset||0),d?_e(i[0]):[],e.currentChunk.samples.map(((e,n)=>[u?_e(t[n]):[],l?_e(r[n]):[],m?_e(i[n]):[],f?Be(o[n]):[]]))])},zt=(e,t)=>Ue("tfra",1,0,[_e(e.track.id),_e(63),_e(e.finalizedChunks.length),e.finalizedChunks.map((r=>[Pe(ir(r.samples[0].timestamp,e.timescale)),Pe(r.moofOffset),_e(t+1),_e(1),_e(1)]))]),It=()=>Ue("mfro",0,0,[_e(0)]),Ot=(e,t,r,i,o)=>Ne("vttc",void 0,[null!==o?Ne("vsid",[Be(o)]):null,null!==r?Ne("iden",[...E.encode(r)]):null,null!==t?Ne("ctim",[...E.encode(ce(t))]):null,null!==i?Ne("sttg",[...E.encode(i)]):null,Ne("payl",[...E.encode(e)])]),Ft=e=>{const t=[];if(e.isQuickTime)Wt(t,e.output._metadataTags);else{const r=Nt(e.output._metadataTags);r&&t.push(r)}return 0===t.length?null:Ne("udta",void 0,t)},Wt=(e,t)=>{for(const{key:r,value:i}of V(t))switch(r){case"title":e.push(Rt("©nam",i));break;case"description":e.push(Rt("©des",i));break;case"artist":e.push(Rt("©ART",i));break;case"album":e.push(Rt("©alb",i));break;case"albumArtist":e.push(Rt("albr",i));break;case"genre":e.push(Rt("©gen",i));break;case"date":e.push(Rt("©day",i.toISOString().slice(0,10)));break;case"comment":e.push(Rt("©cmt",i));break;case"lyrics":e.push(Rt("©lyr",i));break;case"raw":case"discNumber":case"discsTotal":case"trackNumber":case"tracksTotal":case"images":break;default:z(r)}if(t.raw)for(const r in t.raw){const i=t.raw[r];null==i||4!==r.length||e.some((e=>e.type===r))||("string"==typeof i?e.push(Rt(r,i)):i instanceof Uint8Array&&e.push(Ne(r,Array.from(i))))}},Rt=(e,t)=>{const r=E.encode(t);return Ne(e,[Ee(r.length),Ee(qt("und")),Array.from(r)])},Vt={"image/jpeg":13,"image/png":14,"image/bmp":27},Nt=e=>{var t,r,i,o;const n=[];for(const{key:o,value:a}of V(e))switch(o){case"title":n.push(Ut("©nam",a));break;case"description":n.push(Ut("©des",a));break;case"artist":n.push(Ut("©ART",a));break;case"album":n.push(Ut("©alb",a));break;case"albumArtist":n.push(Ut("aART",a));break;case"comment":n.push(Ut("©cmt",a));break;case"genre":n.push(Ut("©gen",a));break;case"lyrics":n.push(Ut("©lyr",a));break;case"date":n.push(Ut("©day",a.toISOString().slice(0,10)));break;case"images":for(const e of a)"coverFront"===e.kind&&n.push(Ne("covr",void 0,[Ne("data",[_e(null!=(t=Vt[e.mimeType])?t:0),_e(0),Array.from(e.data)])]));break;case"trackNumber":n.push(Ne("trkn",void 0,[Ne("data",[_e(0),_e(0),Ee(0),Ee(a),Ee(null!=(r=e.tracksTotal)?r:0),Ee(0)])]));break;case"discNumber":n.push(Ne("disc",void 0,[Ne("data",[_e(0),_e(0),Ee(0),Ee(a),Ee(null!=(i=e.discsTotal)?i:0),Ee(0)])]));break;case"tracksTotal":case"discsTotal":case"raw":break;default:z(o)}if(e.raw)for(const t in e.raw){const r=e.raw[t];null==r||4!==t.length||n.some((e=>e.type===t))||("string"==typeof r?n.push(Ut(t,r)):r instanceof Uint8Array?n.push(Ne(t,void 0,[Ne("data",[_e(0),_e(0),Array.from(r)])])):r instanceof N&&n.push(Ne(t,void 0,[Ne("data",[_e(null!=(o=Vt[r.mimeType])?o:0),_e(0),Array.from(r.data)])])))}return 0===n.length?null:Ue("meta",0,0,void 0,[Ge(!1,"mdir","","appl"),Ne("ilst",void 0,n)])},Ut=(e,t)=>Ne(e,void 0,[Ne("data",[_e(1),_e(0),...E.encode(t)])]),Dt={avc:"avc1",hevc:"hvc1",vp8:"vp08",vp9:"vp09",av1:"av01"},Ht={avc:e=>e.info.decoderConfig&&Ne("avcC",[...T(e.info.decoderConfig.description)]),hevc:e=>e.info.decoderConfig&&Ne("hvcC",[...T(e.info.decoderConfig.description)]),vp8:at,vp9:at,av1:e=>Ne("av1C",(e=>{const t=e.split("."),r=Number(t[1]),i=t[2];return[129,(r<<5)+Number(i.slice(0,-1)),(("H"===i.slice(-1)?1:0)<<7)+((8===Number(t[3])?0:1)<<6)+0+((t[4]?Number(t[4]):0)<<4)+((t[5]?Number(t[5][0]):1)<<3)+((t[5]?Number(t[5][1]):1)<<2)+(t[5]?Number(t[5][2]):0),0]})(e.info.decoderConfig.codec))},Lt=(e,t)=>{switch(e){case"aac":case"mp3":case"vorbis":return"mp4a";case"opus":return"Opus";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(t)switch(e){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":case"pcm-s24be":return"in24";case"pcm-s32":case"pcm-s32be":return"in32";case"pcm-f32":case"pcm-f32be":return"fl32";case"pcm-f64":case"pcm-f64be":return"fl64"}else switch(e){case"pcm-s16":case"pcm-s16be":case"pcm-s24":case"pcm-s24be":case"pcm-s32":case"pcm-s32be":return"ipcm";case"pcm-f32":case"pcm-f32be":case"pcm-f64":case"pcm-f64be":return"fpcm"}},$t=(e,t)=>{switch(e){case"aac":case"mp3":case"vorbis":return ct;case"opus":return ht;case"flac":return mt}if(t)switch(e){case"pcm-s24":case"pcm-s24be":case"pcm-s32":case"pcm-s32be":case"pcm-f32":case"pcm-f32be":case"pcm-f64":case"pcm-f64be":return dt}else switch(e){case"pcm-s16":case"pcm-s16be":case"pcm-s24":case"pcm-s24be":case"pcm-s32":case"pcm-s32be":case"pcm-f32":case"pcm-f32be":case"pcm-f64":case"pcm-f64be":return ft}return null},jt={webvtt:"wvtt"},Qt={webvtt:e=>Ne("vttC",[...E.encode(e.info.config.description)])},qt=e=>{h(3===e.length);let t=0;for(let r=0;r<3;r++)t<<=5,t+=e.charCodeAt(r)-96;return t},Kt=class{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let t=this.getPos();if(t<this.trackedStart){if(t+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-t),t=0}const r=t+e.byteLength-this.trackedStart;let i=this.trackedWrites.byteLength;for(;i<r;)i*=2;if(i!==this.trackedWrites.byteLength){const e=new Uint8Array(i);e.set(this.trackedWrites,0),this.trackedWrites=e}this.trackedWrites.set(e,t-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,t+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(a(2,10)),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const e={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,e}},Xt=a(2,16),Gt=a(2,32),Yt=class extends Kt{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(Xt,{maxByteLength:Gt})}catch(e){this.buffer=new ArrayBuffer(Xt),this.supportsResize=!1}else this.buffer=new ArrayBuffer(Xt);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let t=this.buffer.byteLength;for(;t<e;)t*=2;if(t!==this.buffer.byteLength){if(t>Gt)throw new Error(`ArrayBuffer exceeded maximum size of ${Gt} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(t);else{const e=new ArrayBuffer(t),r=new Uint8Array(e);r.set(this.bytes,0),this.buffer=e,this.bytes=r}}}write(e){var t,r;this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),null==(r=(t=this.target).onwrite)||r.call(t,this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}flush(){return l(this,null,(function*(){}))}finalize(){return l(this,null,(function*(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}))}close(){return l(this,null,(function*(){}))}getSlice(e,t){return this.bytes.slice(e,t)}},Jt=(a(2,24),class extends Kt{constructor(e){super(),this.target=e,this.pos=0}write(e){var t,r;this.maybeTrackWrites(e),null==(r=(t=this.target).onwrite)||r.call(t,this.pos,this.pos+e.byteLength),this.pos+=e.byteLength}getPos(){return this.pos}seek(e){this.pos=e}flush(){return l(this,null,(function*(){}))}finalize(){return l(this,null,(function*(){}))}close(){return l(this,null,(function*(){}))}}),Zt=class{constructor(){this._output=null,this.onwrite=null}},er=class extends Zt{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new Yt(this)}},tr=1e3,rr=e=>{const t={},r=e.track;return void 0!==r.metadata.name&&(t.name=r.metadata.name),t},ir=(e,t,r=!0)=>{const i=e*t;return r?Math.round(i):i},or=class extends ae{constructor(e,t){var r,i;super(e),this.auxTarget=new er,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new ve(this.auxWriter),this.mdat=null,this.trackDatas=[],this.allTracksKnown=A(),this.creationTime=Math.floor(Date.now()/1e3)+2082844800,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=t,this.writer=e._writer,this.boxWriter=new ve(this.writer),this.isQuickTime=t instanceof Cr;const o=this.writer instanceof Yt&&"in-memory";this.fastStart=null!=(r=t._options.fastStart)?r:o,this.isFragmented="fragmented"===this.fastStart,("in-memory"===this.fastStart||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=null!=(i=t._options.minimumFragmentDuration)?i:1}start(){return l(this,null,(function*(){const e=yield this.mutex.acquire(),t=this.output._tracks.some((e=>"video"===e.type&&"avc"===e.source._codec));if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox((r={isQuickTime:this.isQuickTime,holdsAvc:t,fragmented:this.isFragmented}).isQuickTime?Ne("ftyp",[Oe("qt  "),_e(512),Oe("qt  ")]):r.fragmented?Ne("ftyp",[Oe("iso5"),_e(512),Oe("iso5"),Oe("iso6"),Oe("mp41")]):Ne("ftyp",[Oe("isom"),_e(512),Oe("isom"),r.holdsAvc?Oe("avc1"):[],Oe("mp41")])),this.format._options.onFtyp){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onFtyp(e,t)}var r;"in-memory"===this.fastStart?this.mdat=De(!1):this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=De(!0),this.boxWriter.writeBox(this.mdat)),yield this.writer.flush(),e()}))}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some((t=>t.track===e)))return!1;return!0}getMimeType(){return l(this,null,(function*(){yield this.allTracksKnown.promise;const e=this.trackDatas.map((e=>{if("video"===e.type)return e.info.decoderConfig.codec;if("audio"===e.type)return e.info.decoderConfig.codec;return{webvtt:"wvtt"}[e.track.source._codec]}));return(e=>{let t=(e.hasVideo?"video/":e.hasAudio?"audio/":"application/")+(e.isQuickTime?"quicktime":"mp4");e.codecStrings.length>0&&(t+=`; codecs="${[...new Set(e.codecStrings)].join(", ")}"`);return t})({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some((e=>"video"===e.type)),hasAudio:this.trackDatas.some((e=>"audio"===e.type)),codecStrings:e})}))}getVideoTrackData(e,t,r){var i;const o=this.trackDatas.find((t=>t.track===e));if(o)return o;(e=>{if(!e)throw new TypeError("Video chunk metadata must be provided.");if("object"!=typeof e)throw new TypeError("Video chunk metadata must be an object.");if(!e.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if("object"!=typeof e.decoderConfig)throw new TypeError("Video chunk metadata decoder configuration must be an object.");if("string"!=typeof e.decoderConfig.codec)throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!ee.some((t=>e.decoderConfig.codec.startsWith(t))))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(e.decoderConfig.codedWidth)||e.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(e.decoderConfig.codedHeight)||e.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(void 0!==e.decoderConfig.description&&!P(e.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(void 0!==e.decoderConfig.colorSpace){const{colorSpace:t}=e.decoderConfig;if("object"!=typeof t)throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const r=Object.keys(x);if(null!=t.primaries&&!r.includes(t.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${r.join(", ")}.`);const i=Object.keys(_);if(null!=t.transfer&&!i.includes(t.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${i.join(", ")}.`);const o=Object.keys(B);if(null!=t.matrix&&!o.includes(t.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${o.join(", ")}.`);if(null!=t.fullRange&&"boolean"!=typeof t.fullRange)throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(e.decoderConfig.codec.startsWith("avc1")||e.decoderConfig.codec.startsWith("avc3")){if(!te.test(e.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(e.decoderConfig.codec.startsWith("hev1")||e.decoderConfig.codec.startsWith("hvc1")){if(!re.test(e.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(e.decoderConfig.codec.startsWith("vp8")){if("vp8"!==e.decoderConfig.codec)throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(e.decoderConfig.codec.startsWith("vp09")){if(!ie.test(e.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(e.decoderConfig.codec.startsWith("av01")&&!oe.test(e.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')})(r),h(r),h(r.decoderConfig);const n=c({},r.decoderConfig);h(void 0!==n.codedWidth),h(void 0!==n.codedHeight);let a=!1;if("avc"!==e.source._codec||n.description){if("hevc"===e.source._codec&&!n.description){const e=(e=>{try{const t=de(e),r=t.filter((e=>he(e)===p.VPS_NUT)),i=t.filter((e=>he(e)===p.SPS_NUT)),o=t.filter((e=>he(e)===p.PPS_NUT)),n=t.filter((e=>he(e)===p.PREFIX_SEI_NUT||he(e)===p.SUFFIX_SEI_NUT));if(0===i.length||0===o.length)return null;const a=i[0],s=new y(ue(a));s.skipBits(16),s.readBits(4);const c=s.readBits(3),d=s.readBits(1),{general_profile_space:u,general_tier_flag:l,general_profile_idc:h,general_profile_compatibility_flags:m,general_constraint_indicator_flags:f,general_level_idc:w}=me(s,c);v(s);const g=v(s);3===g&&s.skipBits(1),v(s),v(s),s.readBits(1)&&(v(s),v(s),v(s),v(s));const b=v(s),T=v(s);v(s);for(let e=s.readBits(1)?0:c;e<=c;e++)v(s),v(s),v(s);v(s),v(s),v(s),v(s),v(s),v(s),s.readBits(1)&&s.readBits(1)&&fe(s),s.skipBits(1),s.skipBits(1),s.readBits(1)&&(s.skipBits(4),s.skipBits(4),v(s),v(s),s.skipBits(1));const C=v(s);if(pe(s,C),s.readBits(1)){const e=v(s);for(let t=0;t<e;t++)v(s),s.skipBits(1)}s.skipBits(1),s.skipBits(1);let E=0;s.readBits(1)&&(E=ge(s,c));let S=0;if(o.length>0){const e=o[0],t=new y(ue(e));t.skipBits(16),v(t),v(t),t.skipBits(1),t.skipBits(1),t.skipBits(3),t.skipBits(1),t.skipBits(1),v(t),v(t),k(t),t.skipBits(1),t.skipBits(1),t.readBits(1)&&v(t),k(t),k(t),t.skipBits(1),t.skipBits(1),t.skipBits(1),t.skipBits(1);const r=t.readBits(1),i=t.readBits(1);S=r||i?r&&!i?2:!r&&i?3:0:0}return{configurationVersion:1,generalProfileSpace:u,generalTierFlag:l,generalProfileIdc:h,generalProfileCompatibilityFlags:m,generalConstraintIndicatorFlags:f,generalLevelIdc:w,minSpatialSegmentationIdc:E,parallelismType:S,chromaFormatIdc:g,bitDepthLumaMinus8:b,bitDepthChromaMinus8:T,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:c+1,temporalIdNested:d,lengthSizeMinusOne:3,arrays:[...r.length?[{arrayCompleteness:1,nalUnitType:p.VPS_NUT,nalUnits:r}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:p.SPS_NUT,nalUnits:i}]:[],...o.length?[{arrayCompleteness:1,nalUnitType:p.PPS_NUT,nalUnits:o}]:[],...n.length?[{arrayCompleteness:1,nalUnitType:he(n[0]),nalUnits:n}]:[]]}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}})(t.data);if(!e)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");n.description=(e=>{const t=[];t.push(e.configurationVersion),t.push((3&e.generalProfileSpace)<<6|(1&e.generalTierFlag)<<5|31&e.generalProfileIdc),t.push(e.generalProfileCompatibilityFlags>>>24&255),t.push(e.generalProfileCompatibilityFlags>>>16&255),t.push(e.generalProfileCompatibilityFlags>>>8&255),t.push(255&e.generalProfileCompatibilityFlags),t.push(...e.generalConstraintIndicatorFlags),t.push(255&e.generalLevelIdc),t.push(240|e.minSpatialSegmentationIdc>>8&15),t.push(255&e.minSpatialSegmentationIdc),t.push(252|3&e.parallelismType),t.push(252|3&e.chromaFormatIdc),t.push(248|7&e.bitDepthLumaMinus8),t.push(248|7&e.bitDepthChromaMinus8),t.push(e.avgFrameRate>>8&255),t.push(255&e.avgFrameRate),t.push((3&e.constantFrameRate)<<6|(7&e.numTemporalLayers)<<3|(1&e.temporalIdNested)<<2|3&e.lengthSizeMinusOne),t.push(255&e.arrays.length);for(const r of e.arrays){t.push((1&r.arrayCompleteness)<<7|0|63&r.nalUnitType),t.push(r.nalUnits.length>>8&255),t.push(255&r.nalUnits.length);for(const e of r.nalUnits){t.push(e.length>>8&255),t.push(255&e.length);for(let r=0;r<e.length;r++)t.push(e[r])}}return new Uint8Array(t)})(e),a=!0}}else{const e=(e=>{try{const t=de(e),r=t.filter((e=>le(e)===m.SPS)),i=t.filter((e=>le(e)===m.PPS)),o=t.filter((e=>le(e)===m.SPS_EXT));if(0===r.length)return null;if(0===i.length)return null;const n=r[0],a=new y(ue(n));if(a.skipBits(1),a.skipBits(2),7!==a.readBits(5))return console.error("Invalid SPS NAL unit type"),null;const s=a.readAlignedByte(),c={configurationVersion:1,avcProfileIndication:s,profileCompatibility:a.readAlignedByte(),avcLevelIndication:a.readAlignedByte(),lengthSizeMinusOne:3,sequenceParameterSets:r,pictureParameterSets:i,chromaFormat:null,bitDepthLumaMinus8:null,bitDepthChromaMinus8:null,sequenceParameterSetExt:null};if(100===s||110===s||122===s||144===s){v(a);const e=v(a);3===e&&a.skipBits(1);const t=v(a),r=v(a);c.chromaFormat=e,c.bitDepthLumaMinus8=t,c.bitDepthChromaMinus8=r,c.sequenceParameterSetExt=o}return c}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}})(t.data);if(!e)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");n.description=(e=>{const t=[];t.push(e.configurationVersion),t.push(e.avcProfileIndication),t.push(e.profileCompatibility),t.push(e.avcLevelIndication),t.push(252|3&e.lengthSizeMinusOne),t.push(224|31&e.sequenceParameterSets.length);for(const r of e.sequenceParameterSets){const e=r.byteLength;t.push(e>>8),t.push(255&e);for(let i=0;i<e;i++)t.push(r[i])}t.push(e.pictureParameterSets.length);for(const r of e.pictureParameterSets){const e=r.byteLength;t.push(e>>8),t.push(255&e);for(let i=0;i<e;i++)t.push(r[i])}if(100===e.avcProfileIndication||110===e.avcProfileIndication||122===e.avcProfileIndication||144===e.avcProfileIndication){h(null!==e.chromaFormat),h(null!==e.bitDepthLumaMinus8),h(null!==e.bitDepthChromaMinus8),h(null!==e.sequenceParameterSetExt),t.push(252|3&e.chromaFormat),t.push(248|7&e.bitDepthLumaMinus8),t.push(248|7&e.bitDepthChromaMinus8),t.push(e.sequenceParameterSetExt.length);for(const r of e.sequenceParameterSetExt){const e=r.byteLength;t.push(e>>8),t.push(255&e);for(let i=0;i<e;i++)t.push(r[i])}}return new Uint8Array(t)})(e),a=!0}const s=((e,t)=>{const r=e<0?-1:1;let i=0,o=1,n=1,a=0,s=e=Math.abs(e);for(;;){const e=Math.floor(s),c=e*n+i,d=e*a+o;if(d>t)return{numerator:r*n,denominator:a};if(i=n,o=a,n=c,a=d,s=1/(s-e),!isFinite(s))break}return{numerator:r*n,denominator:a}})(1/(null!=(i=e.metadata.frameRate)?i:57600),1e6).denominator,d={muxer:this,track:e,type:"video",info:{width:n.codedWidth,height:n.codedHeight,decoderConfig:n,requiresAnnexBTransformation:a},timescale:s,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(d),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),d}getAudioTrackData(e,t){const r=this.trackDatas.find((t=>t.track===e));if(r)return r;(e=>{if(!e)throw new TypeError("Audio chunk metadata must be provided.");if("object"!=typeof e)throw new TypeError("Audio chunk metadata must be an object.");if(!e.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if("object"!=typeof e.decoderConfig)throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if("string"!=typeof e.decoderConfig.codec)throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!ne.some((t=>e.decoderConfig.codec.startsWith(t))))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(e.decoderConfig.sampleRate)||e.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(e.decoderConfig.numberOfChannels)||e.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(void 0!==e.decoderConfig.description&&!P(e.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(e.decoderConfig.codec.startsWith("mp4a")&&"mp4a.69"!==e.decoderConfig.codec&&"mp4a.6B"!==e.decoderConfig.codec&&"mp4a.6b"!==e.decoderConfig.codec){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(e.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.");if(!e.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.")}else if(e.decoderConfig.codec.startsWith("mp3")||e.decoderConfig.codec.startsWith("mp4a")){if("mp3"!==e.decoderConfig.codec&&"mp4a.69"!==e.decoderConfig.codec&&"mp4a.6B"!==e.decoderConfig.codec&&"mp4a.6b"!==e.decoderConfig.codec)throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(e.decoderConfig.codec.startsWith("opus")){if("opus"!==e.decoderConfig.codec)throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(e.decoderConfig.description&&e.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(e.decoderConfig.codec.startsWith("vorbis")){if("vorbis"!==e.decoderConfig.codec)throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!e.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(e.decoderConfig.codec.startsWith("flac")){if("flac"!==e.decoderConfig.codec)throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');const t=42;if(!e.decoderConfig.description||e.decoderConfig.description.byteLength<t)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((e.decoderConfig.codec.startsWith("pcm")||e.decoderConfig.codec.startsWith("ulaw")||e.decoderConfig.codec.startsWith("alaw"))&&!D.includes(e.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${D.join(", ")}).`)})(t),h(t),h(t.decoderConfig);const i={muxer:this,track:e,type:"audio",info:{numberOfChannels:t.decoderConfig.numberOfChannels,sampleRate:t.decoderConfig.sampleRate,decoderConfig:t.decoderConfig,requiresPcmTransformation:!this.isFragmented&&D.includes(e.source._codec)},timescale:t.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(i),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),i}getSubtitleTrackData(e,t){const r=this.trackDatas.find((t=>t.track===e));if(r)return r;(e=>{if(!e)throw new TypeError("Subtitle metadata must be provided.");if("object"!=typeof e)throw new TypeError("Subtitle metadata must be an object.");if(!e.config)throw new TypeError("Subtitle metadata must include a config object.");if("object"!=typeof e.config)throw new TypeError("Subtitle metadata config must be an object.");if("string"!=typeof e.config.description)throw new TypeError("Subtitle metadata config description must be a string.")})(t),h(t),h(t.config);const i={muxer:this,track:e,type:"subtitle",info:{config:t.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(i),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),i}addEncodedVideoPacket(e,t,r){return l(this,null,(function*(){const i=yield this.mutex.acquire();try{const i=this.getVideoTrackData(e,t,r);let o=t.data;if(i.info.requiresAnnexBTransformation){const e=(e=>{const t=de(e);if(0===t.length)return null;let r=0;for(const e of t)r+=4+e.byteLength;const i=new Uint8Array(r),o=new DataView(i.buffer);let n=0;for(const e of t){const t=e.byteLength;o.setUint32(n,t,!1),n+=4,i.set(e,n),n+=e.byteLength}return i})(o);if(!e)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");o=e}const n=this.validateAndNormalizeTimestamp(i.track,t.timestamp,"key"===t.type),a=this.createSampleForTrack(i,o,n,t.duration,t.type);yield this.registerSample(i,a)}finally{i()}}))}addEncodedAudioPacket(e,t,r){return l(this,null,(function*(){const i=yield this.mutex.acquire();try{const i=this.getAudioTrackData(e,r),o=this.validateAndNormalizeTimestamp(i.track,t.timestamp,"key"===t.type),n=this.createSampleForTrack(i,t.data,o,t.duration,t.type);i.info.requiresPcmTransformation&&(yield this.maybePadWithSilence(i,o)),yield this.registerSample(i,n)}finally{i()}}))}maybePadWithSilence(e,t){return l(this,null,(function*(){const r=g(e.samples),i=r?r.timestamp+r.duration:0,o=t-i,n=ir(o,e.timescale);if(n>0){const{sampleSize:t,silentValue:r}=J(e.info.decoderConfig.codec),a=n*e.info.numberOfChannels,s=new Uint8Array(t*a).fill(r),c=this.createSampleForTrack(e,new Uint8Array(s.buffer),i,o,"key");yield this.registerSample(e,c)}}))}addSubtitleCue(e,t,r){return l(this,null,(function*(){const i=yield this.mutex.acquire();try{const i=this.getSubtitleTrackData(e,r);this.validateAndNormalizeTimestamp(i.track,t.timestamp,!0),"webvtt"===e.source._codec&&(i.cueQueue.push(t),yield this.processWebVTTCues(i,t.timestamp))}finally{i()}}))}processWebVTTCues(e,t){return l(this,null,(function*(){for(var r,i,o,n;e.cueQueue.length>0;){const a=new Set([]);for(const r of e.cueQueue)h(r.timestamp<=t),h(e.lastCueEndTimestamp<=r.timestamp+r.duration),a.add(Math.max(r.timestamp,e.lastCueEndTimestamp)),a.add(r.timestamp+r.duration);const s=[...a].sort(((e,t)=>e-t)),c=s[0],d=null!=(r=s[1])?r:c;if(t<d)break;if(e.lastCueEndTimestamp<c){this.auxWriter.seek(0);const t=Ne("vtte");this.auxBoxWriter.writeBox(t);const r=this.auxWriter.getSlice(0,this.auxWriter.getPos()),i=this.createSampleForTrack(e,r,e.lastCueEndTimestamp,c-e.lastCueEndTimestamp,"key");yield this.registerSample(e,i),e.lastCueEndTimestamp=c}this.auxWriter.seek(0);for(let t=0;t<e.cueQueue.length;t++){const r=e.cueQueue[t];if(r.timestamp>=d)break;se.lastIndex=0;const a=se.test(r.text),s=r.timestamp+r.duration;let u=e.cueToSourceId.get(r);if(void 0===u&&d<s&&(u=e.nextSourceId++,e.cueToSourceId.set(r,u)),r.notes){const e=(n=r.notes,Ne("vtta",[...E.encode(n)]));this.auxBoxWriter.writeBox(e)}const l=Ot(r.text,a?c:null,null!=(i=r.identifier)?i:null,null!=(o=r.settings)?o:null,null!=u?u:null);this.auxBoxWriter.writeBox(l),s===d&&e.cueQueue.splice(t--,1)}const u=this.auxWriter.getSlice(0,this.auxWriter.getPos()),l=this.createSampleForTrack(e,u,c,d-c,"key");yield this.registerSample(e,l),e.lastCueEndTimestamp=d}}))}createSampleForTrack(e,t,r,i,o){return{timestamp:r,decodeTimestamp:r,duration:i,data:t,size:t.byteLength,type:o,timescaleUnitsToNextSample:ir(i,e.timescale)}}processTimestamps(e,t){if(0===e.timestampProcessingQueue.length)return;if("audio"===e.type&&e.info.requiresPcmTransformation){let t=0;for(let r=0;r<e.timestampProcessingQueue.length;r++){const i=e.timestampProcessingQueue[r];t+=ir(i.duration,e.timescale)}if(0===e.timeToSampleTable.length)e.timeToSampleTable.push({sampleCount:t,sampleDelta:1});else{g(e.timeToSampleTable).sampleCount+=t}return void(e.timestampProcessingQueue.length=0)}const r=e.timestampProcessingQueue.map((e=>e.timestamp)).sort(((e,t)=>e-t));for(let t=0;t<e.timestampProcessingQueue.length;t++){const i=e.timestampProcessingQueue[t];i.decodeTimestamp=r[t],this.isFragmented||null!==e.lastTimescaleUnits||(i.decodeTimestamp=0);const o=ir(i.timestamp-i.decodeTimestamp,e.timescale),n=ir(i.duration,e.timescale);if(null!==e.lastTimescaleUnits){h(e.lastSample);const t=ir(i.decodeTimestamp,e.timescale,!1),r=Math.round(t-e.lastTimescaleUnits);if(h(r>=0),e.lastTimescaleUnits+=r,e.lastSample.timescaleUnitsToNextSample=r,!this.isFragmented){let t=g(e.timeToSampleTable);if(h(t),1===t.sampleCount){t.sampleDelta=r;const i=e.timeToSampleTable[e.timeToSampleTable.length-2];i&&i.sampleDelta===r&&(i.sampleCount++,e.timeToSampleTable.pop(),t=i)}else t.sampleDelta!==r&&(t.sampleCount--,e.timeToSampleTable.push(t={sampleCount:1,sampleDelta:r}));t.sampleDelta===n?t.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:n});const i=g(e.compositionTimeOffsetTable);h(i),i.sampleCompositionTimeOffset===o?i.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:o})}}else e.lastTimescaleUnits=ir(i.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:n}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:o}));e.lastSample=i}if(e.timestampProcessingQueue.length=0,h(e.lastSample),h(null!==e.lastTimescaleUnits),void 0!==t&&0===e.lastSample.timescaleUnitsToNextSample){h("key"===t.type);const r=ir(t.timestamp,e.timescale,!1),i=Math.round(r-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=i}}registerSample(e,t){return l(this,null,(function*(){"key"===t.type&&this.processTimestamps(e,t),e.timestampProcessingQueue.push(t),this.isFragmented?(e.sampleQueue.push(t),yield this.interleaveSamples()):yield this.addSampleToTrack(e,t)}))}addSampleToTrack(e,t){return l(this,null,(function*(){this.isFragmented||e.samples.push(t);let r=!1;if(e.currentChunk){e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,t.timestamp);const i=t.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const o=this.trackDatas.every((r=>{if(e===r)return"key"===t.type;const i=r.sampleQueue[0];return i?"key"===i.type:r.track.source._closed}));i>=this.minimumFragmentDuration&&o&&t.timestamp>this.maxWrittenTimestamp&&(r=!0,yield this.finalizeFragment())}else r=i>=.5}else r=!0;r&&(e.currentChunk&&(yield this.finalizeCurrentChunk(e)),e.currentChunk={startTimestamp:t.timestamp,samples:[],offset:null,moofOffset:null}),h(e.currentChunk),e.currentChunk.samples.push(t),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,t.timestamp))}))}finalizeCurrentChunk(e){return l(this,null,(function*(){if(h(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let t=e.currentChunk.samples.length;if("audio"===e.type&&e.info.requiresPcmTransformation&&(t=e.currentChunk.samples.reduce(((t,r)=>t+ir(r.duration,e.timescale)),0)),0!==e.compactlyCodedChunkTable.length&&g(e.compactlyCodedChunkTable).samplesPerChunk===t||e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:t}),"in-memory"!==this.fastStart){e.currentChunk.offset=this.writer.getPos();for(const t of e.currentChunk.samples)h(t.data),this.writer.write(t.data),t.data=null;yield this.writer.flush()}else e.currentChunk.offset=0}))}interleaveSamples(e=!1){return l(this,null,(function*(){if(h(this.isFragmented),e||this.allTracksAreKnown())e:for(;;){let t=null,r=1/0;for(const i of this.trackDatas){if(!e&&0===i.sampleQueue.length&&!i.track.source._closed)break e;i.sampleQueue.length>0&&i.sampleQueue[0].timestamp<r&&(t=i,r=i.sampleQueue[0].timestamp)}if(!t)break;const i=t.sampleQueue.shift();yield this.addSampleToTrack(t,i)}}))}finalizeFragment(e=!0){return l(this,null,(function*(){h(this.isFragmented);const t=this.nextFragmentNumber++;if(1===t){this.format._options.onMoov&&this.writer.startTrackingWrites();const e=He(this,!0);if(this.boxWriter.writeBox(e),this.format._options.onMoov){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMoov(e,t)}}const r=this.trackDatas.filter((e=>e.currentChunk)),i=St(t,r),o=this.writer.getPos(),n=o+this.boxWriter.measureBox(i);let s=n+8,c=1/0;for(const e of r){e.currentChunk.offset=s,e.currentChunk.moofOffset=o;for(const t of e.currentChunk.samples)s+=t.size;c=Math.min(c,e.currentChunk.startTimestamp)}const d=s-n,u=d>=a(2,32);if(u)for(const e of r)e.currentChunk.offset+=8;this.format._options.onMoof&&this.writer.startTrackingWrites();const l=St(t,r);if(this.boxWriter.writeBox(l),this.format._options.onMoof){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMoof(e,t,c)}h(this.writer.getPos()===n),this.format._options.onMdat&&this.writer.startTrackingWrites();const m=De(u);m.size=d,this.boxWriter.writeBox(m),this.writer.seek(n+(u?16:8));for(const e of r)for(const t of e.currentChunk.samples)this.writer.write(t.data),t.data=null;if(this.format._options.onMdat){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMdat(e,t)}for(const e of r)e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk),e.currentChunk=null;e&&(yield this.writer.flush())}))}onTrackClose(e){return l(this,null,(function*(){const t=yield this.mutex.acquire();if("subtitle"===e.type&&"webvtt"===e.source._codec){const t=this.trackDatas.find((t=>t.track===e));t&&(yield this.processWebVTTCues(t,1/0))}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&(yield this.interleaveSamples()),t()}))}finalize(){return l(this,null,(function*(){const e=yield this.mutex.acquire();this.allTracksKnown.resolve();for(const e of this.trackDatas)"subtitle"===e.type&&"webvtt"===e.track.source._codec&&(yield this.processWebVTTCues(e,1/0));if(this.isFragmented){yield this.interleaveSamples(!0);for(const e of this.trackDatas)this.processTimestamps(e);yield this.finalizeFragment(!1)}else for(const e of this.trackDatas)this.processTimestamps(e),yield this.finalizeCurrentChunk(e);if("in-memory"===this.fastStart){let e;h(this.mdat);for(let t=0;t<2;t++){const t=He(this),r=this.boxWriter.measureBox(t);e=this.boxWriter.measureBox(this.mdat);let i=this.writer.getPos()+r+e;for(const t of this.finalizedChunks){t.offset=i;for(const{data:r}of t.samples)h(r),i+=r.byteLength,e+=r.byteLength}if(i<a(2,32))break;e>=a(2,32)&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const t=He(this);if(this.boxWriter.writeBox(t),this.format._options.onMoov){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMoov(e,t)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=e,this.boxWriter.writeBox(this.mdat);for(const e of this.finalizedChunks)for(const t of e.samples)h(t.data),this.writer.write(t.data),t.data=null;if(this.format._options.onMdat){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMdat(e,t)}}else if(this.isFragmented){const e=this.writer.getPos(),r=(t=this.trackDatas,Ne("mfra",void 0,[...t.map(zt),It()]));this.boxWriter.writeBox(r);const i=this.writer.getPos()-e;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(i)}else{h(this.mdat);const e=this.boxWriter.offsets.get(this.mdat);h(void 0!==e);const t=this.writer.getPos()-e;if(this.mdat.size=t,this.mdat.largeSize=t>=a(2,32),this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMdat(e,t)}this.format._options.onMoov&&this.writer.startTrackingWrites();const r=He(this);if(this.boxWriter.writeBox(r),this.format._options.onMoov){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMoov(e,t)}}var t;e()}))}},nr=[],ar=[],sr=new Uint8Array(0),cr=class e{constructor(e,t,r,i,o=-1,n){if(this.data=e,this.type=t,this.timestamp=r,this.duration=i,this.sequenceNumber=o,e===sr&&void 0===n)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(void 0===n&&(n=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if("key"!==t&&"delta"!==t)throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(r))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(i)||i<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(o))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(n)||n<0)throw new TypeError("byteLength must be a non-negative integer.");this.byteLength=n}get isMetadataOnly(){return this.data===sr}get microsecondTimestamp(){return Math.trunc(W*this.timestamp)}get microsecondDuration(){return Math.trunc(W*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if("undefined"==typeof EncodedVideoChunk)throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if("undefined"==typeof EncodedAudioChunk)throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(t){var r;if(!(t instanceof EncodedVideoChunk||t instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const i=new Uint8Array(t.byteLength);return t.copyTo(i),new e(i,t.type,t.timestamp/1e6,(null!=(r=t.duration)?r:0)/1e6)}clone(t){var r,i;if(void 0!==t&&("object"!=typeof t||null===t))throw new TypeError("options, when provided, must be an object.");if(void 0!==(null==t?void 0:t.timestamp)&&!Number.isFinite(t.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if(void 0!==(null==t?void 0:t.duration)&&!Number.isFinite(t.duration))throw new TypeError("options.duration, when provided, must be a number.");return new e(this.data,this.type,null!=(r=null==t?void 0:t.timestamp)?r:this.timestamp,null!=(i=null==t?void 0:t.duration)?i:this.duration,this.sequenceNumber,this.byteLength)}},dr=class e{get displayWidth(){return this.rotation%180==0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180==0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc(W*this.timestamp)}get microsecondDuration(){return Math.trunc(W*this.duration)}constructor(t,r){var i,o,n,a,s,c,d,u,l;if(this._closed=!1,t instanceof ArrayBuffer||ArrayBuffer.isView(t)){if(!r||"object"!=typeof r)throw new TypeError("init must be an object.");if(!("format"in r)||"string"!=typeof r.format)throw new TypeError("init.format must be a string.");if(!Number.isInteger(r.codedWidth)||r.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(r.codedHeight)||r.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(void 0!==r.rotation&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(void 0!==r.duration&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=T(t).slice(),this.format=r.format,this.codedWidth=r.codedWidth,this.codedHeight=r.codedHeight,this.rotation=null!=(i=r.rotation)?i:0,this.timestamp=r.timestamp,this.duration=null!=(o=r.duration)?o:0,this.colorSpace=new VideoColorSpace(r.colorSpace)}else if("undefined"!=typeof VideoFrame&&t instanceof VideoFrame){if(void 0!==(null==r?void 0:r.rotation)&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(void 0!==(null==r?void 0:r.timestamp)&&!Number.isFinite(null==r?void 0:r.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if(void 0!==(null==r?void 0:r.duration)&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=t,this.format=t.format,this.codedWidth=t.displayWidth,this.codedHeight=t.displayHeight,this.rotation=null!=(n=null==r?void 0:r.rotation)?n:0,this.timestamp=null!=(a=null==r?void 0:r.timestamp)?a:t.timestamp/1e6,this.duration=null!=(c=null==r?void 0:r.duration)?c:(null!=(s=t.duration)?s:0)/1e6,this.colorSpace=t.colorSpace}else{if(!("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof SVGImageElement&&t instanceof SVGImageElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap||"undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas))throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.");{if(!r||"object"!=typeof r)throw new TypeError("init must be an object.");if(void 0!==r.rotation&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(void 0!==r.duration&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if("undefined"!=typeof VideoFrame)return new e(new VideoFrame(t,{timestamp:Math.trunc(r.timestamp*W),duration:Math.trunc((null!=(d=r.duration)?d:0)*W)}),r);let i=0,o=0;if("naturalWidth"in t?(i=t.naturalWidth,o=t.naturalHeight):"videoWidth"in t?(i=t.videoWidth,o=t.videoHeight):"width"in t&&(i=Number(t.width),o=Number(t.height)),!i||!o)throw new TypeError("Could not determine dimensions.");const n=new OffscreenCanvas(i,o),a=n.getContext("2d",{alpha:!1,willReadFrequently:!0});h(a),a.drawImage(t,0,0),this._data=n,this.format="RGBX",this.codedWidth=i,this.codedHeight=o,this.rotation=null!=(u=r.rotation)?u:0,this.timestamp=r.timestamp,this.duration=null!=(l=r.duration)?l:0,this.colorSpace=new VideoColorSpace({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}}}clone(){if(this._closed)throw new Error("VideoSample is closed.");return h(null!==this._data),ur(this._data)?new e(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?new e(this._data.slice(),{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation}):new e(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||(ur(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(){if(this._closed)throw new Error("VideoSample is closed.");return h(null!==this._data),ur(this._data)?this._data.allocationSize():this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}copyTo(e){return l(this,null,(function*(){if(!P(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(this._closed)throw new Error("VideoSample is closed.");if(h(null!==this._data),ur(this._data))yield this._data.copyTo(e);else if(this._data instanceof Uint8Array){T(e).set(this._data)}else{const t=this._data.getContext("2d",{alpha:!1});h(t);const r=t.getImageData(0,0,this.codedWidth,this.codedHeight);T(e).set(r.data)}}))}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return h(null!==this._data),ur(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}draw(e,t,r,i,o,n,a,s,c){let d=0,u=0,l=this.displayWidth,h=this.displayHeight,m=0,f=0,p=this.displayWidth,w=this.displayHeight;if(void 0!==n?(d=t,u=r,l=i,h=o,m=n,f=a,void 0!==s?(p=s,w=c):(p=l,w=h)):(m=t,f=r,void 0!==i&&(p=i,w=o)),!("undefined"!=typeof CanvasRenderingContext2D&&e instanceof CanvasRenderingContext2D||"undefined"!=typeof OffscreenCanvasRenderingContext2D&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(d))throw new TypeError("sx must be a number.");if(!Number.isFinite(u))throw new TypeError("sy must be a number.");if(!Number.isFinite(l)||l<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(h)||h<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(m))throw new TypeError("dx must be a number.");if(!Number.isFinite(f))throw new TypeError("dy must be a number.");if(!Number.isFinite(p)||p<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(w)||w<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");({sx:d,sy:u,sWidth:l,sHeight:h}=this._rotateSourceRegion(d,u,l,h,this.rotation));const g=this.toCanvasImageSource();e.save();const b=m+p/2,y=f+w/2;e.translate(b,y),e.rotate(this.rotation*Math.PI/180);const v=this.rotation%180==0?1:p/w;e.scale(1/v,v),e.drawImage(g,d,u,l,h,-p/2,-w/2,p,w),e.restore()}drawWithFit(e,t){var r,i,o,n,a,s,c,d,u;if(!("undefined"!=typeof CanvasRenderingContext2D&&e instanceof CanvasRenderingContext2D||"undefined"!=typeof OffscreenCanvasRenderingContext2D&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!t||"object"!=typeof t)throw new TypeError("options must be an object.");if(!["fill","contain","cover"].includes(t.fit))throw new TypeError("options.fit must be 'fill', 'contain', or 'cover'.");if(void 0!==t.rotation&&![0,90,180,270].includes(t.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180, or 270.");void 0!==t.crop&&hr(t.crop,"options.");const l=e.canvas.width,h=e.canvas.height,m=null!=(r=t.rotation)?r:this.rotation,[f,p]=m%180==0?[this.codedWidth,this.codedHeight]:[this.codedHeight,this.codedWidth];let w,g,b,y;t.crop&&lr(t.crop,f,p);const{sx:v,sy:k,sWidth:T,sHeight:C}=this._rotateSourceRegion(null!=(o=null==(i=t.crop)?void 0:i.left)?o:0,null!=(a=null==(n=t.crop)?void 0:n.top)?a:0,null!=(c=null==(s=t.crop)?void 0:s.width)?c:this.codedWidth,null!=(u=null==(d=t.crop)?void 0:d.height)?u:this.codedHeight,m);if("fill"===t.fit)w=0,g=0,b=l,y=h;else{const[e,r]=t.crop?[t.crop.width,t.crop.height]:[f,p],i="contain"===t.fit?Math.min(l/e,h/r):Math.max(l/e,h/r);b=e*i,y=r*i,w=(l-b)/2,g=(h-y)/2}const E=m%180==0?1:b/y;e.translate(l/2,h/2),e.rotate(m*Math.PI/180),e.scale(1/E,E),e.translate(-l/2,-h/2),e.drawImage(this.toCanvasImageSource(),v,k,T,C,w,g,b,y)}_rotateSourceRegion(e,t,r,i,o){return 90===o?[e,t,r,i]=[t,this.codedHeight-e-r,i,r]:180===o?[e,t]=[this.codedWidth-e-r,this.codedHeight-t-i]:270===o&&([e,t,r,i]=[this.codedWidth-t-i,e,i,r]),{sx:e,sy:t,sWidth:r,sHeight:i}}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(h(null!==this._data),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask((()=>e.close())),e}return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}},ur=e=>"undefined"!=typeof VideoFrame&&e instanceof VideoFrame,lr=(e,t,r)=>{e.left=Math.min(e.left,t),e.top=Math.min(e.top,r),e.width=Math.min(e.width,t-e.left),e.height=Math.min(e.height,r-e.top),h(e.width>=0),h(e.height>=0)},hr=(e,t)=>{if(!e||"object"!=typeof e)throw new TypeError(t+"crop, when provided, must be an object.");if(!Number.isInteger(e.left)||e.left<0)throw new TypeError(t+"crop.left must be a non-negative integer.");if(!Number.isInteger(e.top)||e.top<0)throw new TypeError(t+"crop.top must be a non-negative integer.");if(!Number.isInteger(e.width)||e.width<0)throw new TypeError(t+"crop.width must be a non-negative integer.");if(!Number.isInteger(e.height)||e.height<0)throw new TypeError(t+"crop.height must be a non-negative integer.")},mr=new Set(["f32","f32-planar","s16","s16-planar","s32","s32-planar","u8","u8-planar"]),fr=class e{get microsecondTimestamp(){return Math.trunc(W*this.timestamp)}get microsecondDuration(){return Math.trunc(W*this.duration)}constructor(e){if(this._closed=!1,yr(e)){if(null===e.format)throw new TypeError("AudioData with null format is not supported.");this._data=e,this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=e.numberOfFrames,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp/1e6,this.duration=e.numberOfFrames/e.sampleRate}else{if(!e||"object"!=typeof e)throw new TypeError("Invalid AudioDataInit: must be an object.");if(!mr.has(e.format))throw new TypeError("Invalid AudioDataInit: invalid format.");if(!Number.isFinite(e.sampleRate)||e.sampleRate<=0)throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");if(!Number.isInteger(e.numberOfChannels)||0===e.numberOfChannels)throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");if(!Number.isFinite(null==e?void 0:e.timestamp))throw new TypeError("init.timestamp must be a number.");const t=e.data.byteLength/(pr(e.format)*e.numberOfChannels);if(!Number.isInteger(t))throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");let r;if(this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=t,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp,this.duration=t/e.sampleRate,e.data instanceof ArrayBuffer)r=new Uint8Array(e.data);else{if(!ArrayBuffer.isView(e.data))throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");r=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength)}const i=this.numberOfFrames*this.numberOfChannels*pr(this.format);if(r.byteLength<i)throw new TypeError("Invalid AudioDataInit: insufficient data size.");this._data=r}}allocationSize(e){var t,r;if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(!Number.isInteger(e.planeIndex)||e.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(void 0!==e.format&&!mr.has(e.format))throw new TypeError("Invalid format.");if(void 0!==e.frameOffset&&(!Number.isInteger(e.frameOffset)||e.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(void 0!==e.frameCount&&(!Number.isInteger(e.frameCount)||e.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const i=null!=(t=e.format)?t:this.format,o=null!=(r=e.frameOffset)?r:0;if(o>=this.numberOfFrames)throw new RangeError("frameOffset out of range");const n=void 0!==e.frameCount?e.frameCount:this.numberOfFrames-o;if(n>this.numberOfFrames-o)throw new RangeError("frameCount out of range");const a=pr(i),s=wr(i);if(s&&e.planeIndex>=this.numberOfChannels)throw new RangeError("planeIndex out of range");if(!s&&0!==e.planeIndex)throw new RangeError("planeIndex out of range");return(s?n:n*this.numberOfChannels)*a}copyTo(e,t){if(!P(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(!t||"object"!=typeof t)throw new TypeError("options must be an object.");if(!Number.isInteger(t.planeIndex)||t.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(void 0!==t.format&&!mr.has(t.format))throw new TypeError("Invalid format.");if(void 0!==t.frameOffset&&(!Number.isInteger(t.frameOffset)||t.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(void 0!==t.frameCount&&(!Number.isInteger(t.frameCount)||t.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const{planeIndex:r,format:i,frameCount:o,frameOffset:n}=t,a=null!=i?i:this.format;if(!a)throw new Error("Destination format not determined");const s=this.numberOfFrames,c=this.numberOfChannels,d=null!=n?n:0;if(d>=s)throw new RangeError("frameOffset out of range");const u=void 0!==o?o:s-d;if(u>s-d)throw new RangeError("frameCount out of range");const l=pr(a),h=wr(a);if(h&&r>=c)throw new RangeError("planeIndex out of range");if(!h&&0!==r)throw new RangeError("planeIndex out of range");const m=(h?u:u*c)*l;if(e.byteLength<m)throw new RangeError("Destination buffer is too small");const f=C(e),p=br(a);if(yr(this._data))if(h)if("f32-planar"===a)this._data.copyTo(e,{planeIndex:r,frameOffset:d,frameCount:u,format:"f32-planar"});else{const e=new ArrayBuffer(4*u),t=new Float32Array(e);this._data.copyTo(t,{planeIndex:r,frameOffset:d,frameCount:u,format:"f32-planar"});const i=new DataView(e);for(let e=0;e<u;e++){p(f,e*l,i.getFloat32(4*e,!0))}}else{const e=c,t=new Float32Array(u);for(let r=0;r<e;r++){this._data.copyTo(t,{planeIndex:r,frameOffset:d,frameCount:u,format:"f32-planar"});for(let i=0;i<u;i++){p(f,(i*e+r)*l,t[i])}}}else{const e=this._data,t=new DataView(e.buffer,e.byteOffset,e.byteLength),i=this.format,o=gr(i),n=pr(i),a=wr(i);for(let e=0;e<u;e++)if(h){let i;i=a?(r*s+(e+d))*n:((e+d)*c+r)*n;p(f,e*l,o(t,i))}else for(let r=0;r<c;r++){let i;i=a?(r*s+(e+d))*n:((e+d)*c+r)*n;p(f,(e*c+r)*l,o(t,i))}}}clone(){if(this._closed)throw new Error("AudioSample is closed.");if(yr(this._data)){const t=new e(this._data.clone());return t.setTimestamp(this.timestamp),t}return new e({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.timestamp,data:this._data})}close(){this._closed||(yr(this._data)?this._data.close():this._data=new Uint8Array(0),this._closed=!0)}toAudioData(){if(this._closed)throw new Error("AudioSample is closed.");if(yr(this._data)){if(this._data.timestamp===this.microsecondTimestamp)return this._data.clone();if(wr(this.format)){const e=this.allocationSize({planeIndex:0,format:this.format}),t=new ArrayBuffer(e*this.numberOfChannels);for(let r=0;r<this.numberOfChannels;r++)this.copyTo(new Uint8Array(t,r*e,e),{planeIndex:r,format:this.format});return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:t})}{const e=new ArrayBuffer(this.allocationSize({planeIndex:0,format:this.format}));return this.copyTo(e,{planeIndex:0,format:this.format}),new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:e})}}return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:this._data})}toAudioBuffer(){if(this._closed)throw new Error("AudioSample is closed.");const e=new AudioBuffer({numberOfChannels:this.numberOfChannels,length:this.numberOfFrames,sampleRate:this.sampleRate}),t=new Float32Array(this.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let r=0;r<this.numberOfChannels;r++)this.copyTo(t,{planeIndex:r,format:"f32-planar"}),e.copyToChannel(t,r);return e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}static*_fromAudioBuffer(t,r){if(!(t instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const i=t.numberOfChannels,o=t.sampleRate,n=t.length,a=Math.floor(24e4/i);let s=0,c=n;for(;c>0;){const n=Math.min(a,c),d=new Float32Array(i*n);for(let e=0;e<i;e++)t.copyFromChannel(d.subarray(e*n,(e+1)*n),e,s);yield new e({format:"f32-planar",sampleRate:o,numberOfFrames:n,numberOfChannels:i,timestamp:r+s/o,data:d}),s+=n,c-=n}}static fromAudioBuffer(t,r){if(!(t instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const i=t.numberOfChannels,o=t.sampleRate,n=t.length,a=Math.floor(24e4/i);let s=0,c=n;const d=[];for(;c>0;){const n=Math.min(a,c),u=new Float32Array(i*n);for(let e=0;e<i;e++)t.copyFromChannel(u.subarray(e*n,(e+1)*n),e,s);const l=new e({format:"f32-planar",sampleRate:o,numberOfFrames:n,numberOfChannels:i,timestamp:r+s/o,data:u});d.push(l),s+=n,c-=n}return d}},pr=e=>{switch(e){case"u8":case"u8-planar":return 1;case"s16":case"s16-planar":return 2;case"s32":case"s32-planar":case"f32":case"f32-planar":return 4;default:throw new Error("Unknown AudioSampleFormat")}},wr=e=>{switch(e){case"u8-planar":case"s16-planar":case"s32-planar":case"f32-planar":return!0;default:return!1}},gr=e=>{switch(e){case"u8":case"u8-planar":return(e,t)=>(e.getUint8(t)-128)/128;case"s16":case"s16-planar":return(e,t)=>e.getInt16(t,!0)/32768;case"s32":case"s32-planar":return(e,t)=>e.getInt32(t,!0)/2147483648;case"f32":case"f32-planar":return(e,t)=>e.getFloat32(t,!0)}},br=e=>{switch(e){case"u8":case"u8-planar":return(e,t,r)=>e.setUint8(t,O(127.5*(r+1),0,255));case"s16":case"s16-planar":return(e,t,r)=>e.setInt16(t,O(Math.round(32767*r),-32768,32767),!0);case"s32":case"s32-planar":return(e,t,r)=>e.setInt32(t,O(Math.round(2147483647*r),-2147483648,2147483647),!0);case"f32":case"f32-planar":return(e,t,r)=>e.setFloat32(t,r,!0)}},yr=e=>"undefined"!=typeof AudioData&&e instanceof AudioData,vr=class{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter((e=>U.includes(e)))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter((e=>L.includes(e)))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter((e=>$.includes(e)))}_codecUnsupportedHint(e){return""}},kr=class extends vr{constructor(e={}){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(void 0!==e.fastStart&&![!1,"in-memory","fragmented"].includes(e.fastStart))throw new TypeError('options.fastStart, when provided, must be false, "in-memory", or "fragmented".');if(void 0!==e.minimumFragmentDuration&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(void 0!==e.onFtyp&&"function"!=typeof e.onFtyp)throw new TypeError("options.onFtyp, when provided, must be a function.");if(void 0!==e.onMoov&&"function"!=typeof e.onMoov)throw new TypeError("options.onMoov, when provided, must be a function.");if(void 0!==e.onMdat&&"function"!=typeof e.onMdat)throw new TypeError("options.onMdat, when provided, must be a function.");if(void 0!==e.onMoof&&"function"!=typeof e.onMoof)throw new TypeError("options.onMoof, when provided, must be a function.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:a(2,32)-1}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new or(e,this)}},Tr=class extends kr{constructor(e){super(e)}get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...U,...H,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...$]}_codecUnsupportedHint(e){return(new Cr).getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}},Cr=class extends kr{constructor(e){super(e)}get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...U,...L]}_codecUnsupportedHint(e){return(new Tr).getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}},Er=(e,t)=>{if(!t||"object"!=typeof t)throw new TypeError("Encoding options must be an object.");if(void 0!==t.bitrateMode&&!["constant","variable"].includes(t.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(void 0!==t.latencyMode&&!["quality","realtime"].includes(t.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(void 0!==t.fullCodecString&&"string"!=typeof t.fullCodecString)throw new TypeError("fullCodecString, when provided, must be a string.");if(void 0!==t.fullCodecString&&Z(t.fullCodecString)!==e)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${e}).`);if(void 0!==t.hardwareAcceleration&&!["no-preference","prefer-hardware","prefer-software"].includes(t.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(void 0!==t.scalabilityMode&&"string"!=typeof t.scalabilityMode)throw new TypeError("scalabilityMode, when provided, must be a string.");if(void 0!==t.contentHint&&"string"!=typeof t.contentHint)throw new TypeError("contentHint, when provided, must be a string.")},Sr=e=>{var t;const r=e.bitrate instanceof Br?e.bitrate._toVideoBitrate(e.codec,e.width,e.height):e.bitrate;return c({codec:null!=(t=e.fullCodecString)?t:X(e.codec,e.width,e.height,r),width:e.width,height:e.height,bitrate:r,bitrateMode:e.bitrateMode,framerate:e.framerate,latencyMode:e.latencyMode,hardwareAcceleration:e.hardwareAcceleration,scalabilityMode:e.scalabilityMode,contentHint:e.contentHint},"avc"===(i=e.codec)?{avc:{format:"avc"}}:"hevc"===i?{hevc:{format:"hevc"}}:{});var i},xr=(e,t)=>{if(!t||"object"!=typeof t)throw new TypeError("Encoding options must be an object.");if(void 0!==t.bitrateMode&&!["constant","variable"].includes(t.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(void 0!==t.fullCodecString&&"string"!=typeof t.fullCodecString)throw new TypeError("fullCodecString, when provided, must be a string.");if(void 0!==t.fullCodecString&&Z(t.fullCodecString)!==e)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${e}).`)},_r=e=>{var t;const r=e.bitrate instanceof Br?e.bitrate._toAudioBitrate(e.codec):e.bitrate;return c({codec:null!=(t=e.fullCodecString)?t:G(e.codec,e.numberOfChannels,e.sampleRate),numberOfChannels:e.numberOfChannels,sampleRate:e.sampleRate,bitrate:r,bitrateMode:e.bitrateMode},"aac"===(i=e.codec)?{aac:{format:"aac"}}:"opus"===i?{opus:{format:"opus"}}:{});var i},Br=class{constructor(e){this._factor=e}_toVideoBitrate(e,t,r){const i=t*r,o=3e6*Math.pow(i/2073600,.95)*{avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2}[e]*this._factor;return 1e3*Math.ceil(o/1e3)}_toAudioBitrate(e){if(D.includes(e)||"flac"===e)return;const t={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!t)throw new Error(`Unhandled codec: ${e}`);let r=t*this._factor;if("aac"===e){r=[96e3,128e3,16e4,192e3].reduce(((e,t)=>Math.abs(t-r)<Math.abs(e-r)?t:e))}else if("opus"===e||"vorbis"===e)r=Math.max(6e3,r);else if("mp3"===e){r=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce(((e,t)=>Math.abs(t-r)<Math.abs(e-r)?t:e))}return 1e3*Math.round(r/1e3)}},Pr=(new Br(.3),new Br(.6)),Mr=new Br(1),Ar=new Br(2),zr=(new Br(4),(e,...t)=>l(null,[e,...t],(function*(e,t={}){const r=t,{width:i=1280,height:o=720,bitrate:n=1e6}=r,a=u(r,["width","height","bitrate"]);if(!U.includes(e))return!1;if(!Number.isInteger(i)||i<=0)throw new TypeError("width must be a positive integer.");if(!Number.isInteger(o)||o<=0)throw new TypeError("height must be a positive integer.");if(!(n instanceof Br)&&(!Number.isInteger(n)||n<=0))throw new TypeError("bitrate must be a positive integer or a quality.");Er(e,a);let s=null;if(nr.length>0&&(null!=s||(s=Sr(c({codec:e,width:i,height:o,bitrate:n,framerate:void 0},a))),nr.some((t=>t.supports(e,s)))))return!0;if("undefined"==typeof VideoEncoder)return!1;null!=s||(s=Sr(c({codec:e,width:i,height:o,bitrate:n,framerate:void 0},a)));return!0===(yield VideoEncoder.isConfigSupported(s)).supported}))),Ir=(e,...t)=>l(null,[e,...t],(function*(e,t={}){const r=t,{numberOfChannels:i=2,sampleRate:o=48e3,bitrate:n=128e3}=r,a=u(r,["numberOfChannels","sampleRate","bitrate"]);if(!L.includes(e))return!1;if(!Number.isInteger(i)||i<=0)throw new TypeError("numberOfChannels must be a positive integer.");if(!Number.isInteger(o)||o<=0)throw new TypeError("sampleRate must be a positive integer.");if(!(n instanceof Br)&&(!Number.isInteger(n)||n<=0))throw new TypeError("bitrate must be a positive integer.");xr(e,a);let s=null;if(ar.length>0&&(null!=s||(s=_r(c({codec:e,numberOfChannels:i,sampleRate:o,bitrate:n},a))),ar.some((t=>t.supports(e,s)))))return!0;if(D.includes(e))return!0;if("undefined"==typeof AudioEncoder)return!1;null!=s||(s=_r(c({codec:e,numberOfChannels:i,sampleRate:o,bitrate:n},a)));return!0===(yield AudioEncoder.isConfigSupported(s)).supported})),Or=class{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if("canceled"===this._connectedTrack.output.state)throw new Error("Output has been canceled.");if("finalizing"===this._connectedTrack.output.state||"finalized"===this._connectedTrack.output.state)throw new Error("Output has been finalized.");if("pending"===this._connectedTrack.output.state)throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}_start(){return l(this,null,(function*(){}))}_flushAndClose(e){return l(this,null,(function*(){}))}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if("pending"===e.output.state)throw new Error("Cannot call close before output has been started.");this._closingPromise=(()=>l(this,null,(function*(){yield this._flushAndClose(!1),this._closed=!0,"finalizing"!==e.output.state&&"finalized"!==e.output.state&&e.output._muxer.onTrackClose(e)})))()}_flushOrWaitForOngoingClose(e){return l(this,null,(function*(){return this._closingPromise?this._closingPromise:this._flushAndClose(e)}))}},Fr=class extends Or{constructor(e){if(super(),this._connectedTrack=null,!U.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${U.join(", ")}.`);this._codec=e}},Wr=class{constructor(e,t){this.source=e,this.encodingConfig=t,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.codedWidth=null,this.codedHeight=null,this.resizeCanvas=null,this.customEncoder=null,this.customEncoderCallSerializer=new R,this.customEncoderQueueSize=0,this.encoderError=null}add(e,t,r){return l(this,null,(function*(){var i,o;try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),null!==this.codedWidth&&null!==this.codedHeight){if(e.codedWidth!==this.codedWidth||e.codedHeight!==this.codedHeight){const r=null!=(i=this.encodingConfig.sizeChangeBehavior)?i:"deny";if("passThrough"===r);else{if("deny"===r)throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${e.codedWidth}x${e.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`);{let i=!1;this.resizeCanvas||("undefined"!=typeof document?(this.resizeCanvas=document.createElement("canvas"),this.resizeCanvas.width=this.codedWidth,this.resizeCanvas.height=this.codedHeight):this.resizeCanvas=new OffscreenCanvas(this.codedWidth,this.codedHeight),i=!0);const o=this.resizeCanvas.getContext("2d",{alpha:!1});h(o),i||o.clearRect(0,0,this.codedWidth,this.codedHeight),e.drawWithFit(o,{fit:r}),t&&e.close(),e=new dr(this.resizeCanvas,{timestamp:e.timestamp,duration:e.duration,rotation:e.rotation}),t=!0}}}}else this.codedWidth=e.codedWidth,this.codedHeight=e.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||(yield this.ensureEncoderPromise)),h(this.encoderInitialized);const n=null!=(o=this.encodingConfig.keyFrameInterval)?o:5,a=Math.floor(e.timestamp/n),s=d(c({},r),{keyFrame:(null==r?void 0:r.keyFrame)||0===n||a!==this.lastMultipleOfKeyFrameInterval});if(this.lastMultipleOfKeyFrameInterval=a,this.customEncoder){this.customEncoderQueueSize++;const t=e.clone(),r=this.customEncoderCallSerializer.call((()=>this.customEncoder.encode(t,s))).then((()=>this.customEncoderQueueSize--)).catch((e=>{var t;return null!=(t=this.encoderError)?t:this.encoderError=e})).finally((()=>{t.close()}));this.customEncoderQueueSize>=4&&(yield r)}else{h(this.encoder);const r=e.toVideoFrame();this.encoder.encode(r,s),r.close(),t&&e.close(),this.encoder.encodeQueueSize>=4&&(yield new Promise((e=>this.encoder.addEventListener("dequeue",e,{once:!0}))))}yield this.muxer.mutex.currentPromise}finally{t&&e.close()}}))}ensureEncoder(e){return l(this,null,(function*(){if(this.encoder)return;const t=new Error;return this.ensureEncoderPromise=(()=>l(this,null,(function*(){var r,i,o,n;const a=Sr(d(c({width:e.codedWidth,height:e.codedHeight},this.encodingConfig),{framerate:null==(r=this.source._connectedTrack)?void 0:r.metadata.frameRate}));null==(o=(i=this.encodingConfig).onEncoderConfig)||o.call(i,a);const s=nr.find((e=>e.supports(this.encodingConfig.codec,a)));if(s)this.customEncoder=new s,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=a,this.customEncoder.onPacket=(e,t)=>{var r,i;if(!(e instanceof cr))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(void 0!==t&&(!t||"object"!=typeof t))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");null==(i=(r=this.encodingConfig).onEncodedPacket)||i.call(r,e,t),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,e,t)},yield this.customEncoder.init();else{if("undefined"==typeof VideoEncoder)throw new Error("VideoEncoder is not supported by this browser.");if(!(yield VideoEncoder.isConfigSupported(a)).supported)throw new Error(`This specific encoder configuration (${a.codec}, ${a.bitrate} bps, ${a.width}x${a.height}, hardware acceleration: ${null!=(n=a.hardwareAcceleration)?n:"no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`);this.encoder=new VideoEncoder({output:(e,t)=>{var r,i;const o=cr.fromEncodedChunk(e);null==(i=(r=this.encodingConfig).onEncodedPacket)||i.call(r,o,t),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,o,t)},error:e=>{e.stack=t.stack,null!=this.encoderError||(this.encoderError=e)}}),this.encoder.configure(a)}h(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})))()}))}flushAndClose(e){return l(this,null,(function*(){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call((()=>this.customEncoder.flush())),yield this.customEncoderCallSerializer.call((()=>this.customEncoder.close()))):this.encoder&&(e||(yield this.encoder.flush()),"closed"!==this.encoder.state&&this.encoder.close()),e||this.checkForEncoderError()}))}getQueueSize(){var e,t;return this.customEncoder?this.customEncoderQueueSize:null!=(t=null==(e=this.encoder)?void 0:e.encodeQueueSize)?t:0}checkForEncoderError(){if(this.encoderError)throw this.encoderError.stack=(new Error).stack,this.encoderError}},Rr=class extends Or{constructor(e){if(super(),this._connectedTrack=null,!L.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${L.join(", ")}.`);this._codec=e}},Vr=class{constructor(e,t){this.source=e,this.encodingConfig=t,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastNumberOfChannels=null,this.lastSampleRate=null,this.isPcmEncoder=!1,this.outputSampleSize=null,this.writeOutputValue=null,this.customEncoder=null,this.customEncoderCallSerializer=new R,this.customEncoderQueueSize=0,this.encoderError=null}add(e,t){return l(this,null,(function*(){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),null!==this.lastNumberOfChannels&&null!==this.lastSampleRate){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;if(this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||(yield this.ensureEncoderPromise)),h(this.encoderInitialized),this.customEncoder){this.customEncoderQueueSize++;const t=e.clone(),r=this.customEncoderCallSerializer.call((()=>this.customEncoder.encode(t))).then((()=>this.customEncoderQueueSize--)).catch((e=>{var t;return null!=(t=this.encoderError)?t:this.encoderError=e})).finally((()=>{t.close()}));this.customEncoderQueueSize>=4&&(yield r),yield this.muxer.mutex.currentPromise}else if(this.isPcmEncoder)yield this.doPcmEncoding(e,t);else{h(this.encoder);const r=e.toAudioData();this.encoder.encode(r),r.close(),t&&e.close(),this.encoder.encodeQueueSize>=4&&(yield new Promise((e=>this.encoder.addEventListener("dequeue",e,{once:!0})))),yield this.muxer.mutex.currentPromise}}finally{t&&e.close()}}))}doPcmEncoding(e,t){return l(this,null,(function*(){var r,i;h(this.outputSampleSize),h(this.writeOutputValue);const{numberOfChannels:o,numberOfFrames:n,sampleRate:a,timestamp:s}=e,c=2048,d=[];for(let t=0;t<n;t+=c){const r=Math.min(c,e.numberOfFrames-t),i=r*o*this.outputSampleSize,n=new ArrayBuffer(i),a=new DataView(n);d.push({frameCount:r,view:a})}const u=e.allocationSize({planeIndex:0,format:"f32-planar"}),l=new Float32Array(u/Float32Array.BYTES_PER_ELEMENT);for(let t=0;t<o;t++){e.copyTo(l,{planeIndex:t,format:"f32-planar"});for(let e=0;e<d.length;e++){const{frameCount:r,view:i}=d[e];for(let n=0;n<r;n++)this.writeOutputValue(i,(n*o+t)*this.outputSampleSize,l[e*c+n])}}t&&e.close();const m={decoderConfig:{codec:this.encodingConfig.codec,numberOfChannels:o,sampleRate:a}};for(let e=0;e<d.length;e++){const{frameCount:t,view:o}=d[e],n=o.buffer,u=e*c,l=new cr(new Uint8Array(n),"key",s+u/a,t/a);null==(i=(r=this.encodingConfig).onEncodedPacket)||i.call(r,l,m),yield this.muxer.addEncodedAudioPacket(this.source._connectedTrack,l,m)}}))}ensureEncoder(e){if(this.encoderInitialized)return;const t=new Error;return this.ensureEncoderPromise=(()=>l(this,null,(function*(){var r,i;const{numberOfChannels:o,sampleRate:n}=e,a=_r(c({numberOfChannels:o,sampleRate:n},this.encodingConfig));null==(i=(r=this.encodingConfig).onEncoderConfig)||i.call(r,a);const s=ar.find((e=>e.supports(this.encodingConfig.codec,a)));if(s)this.customEncoder=new s,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=a,this.customEncoder.onPacket=(e,t)=>{var r,i;if(!(e instanceof cr))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(void 0!==t&&(!t||"object"!=typeof t))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");null==(i=(r=this.encodingConfig).onEncodedPacket)||i.call(r,e,t),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,e,t)},yield this.customEncoder.init();else if(D.includes(this.encodingConfig.codec))this.initPcmEncoder();else{if("undefined"==typeof AudioEncoder)throw new Error("AudioEncoder is not supported by this browser.");if(!(yield AudioEncoder.isConfigSupported(a)).supported)throw new Error(`This specific encoder configuration (${a.codec}, ${a.bitrate} bps, ${a.numberOfChannels} channels, ${a.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`);this.encoder=new AudioEncoder({output:(e,t)=>{var r,i;const o=cr.fromEncodedChunk(e);null==(i=(r=this.encodingConfig).onEncodedPacket)||i.call(r,o,t),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,o,t)},error:e=>{e.stack=t.stack,null!=this.encoderError||(this.encoderError=e)}}),this.encoder.configure(a)}h(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})))()}initPcmEncoder(){this.isPcmEncoder=!0;const e=this.encodingConfig.codec,{dataType:t,sampleSize:r,littleEndian:i}=J(e);switch(this.outputSampleSize=r,r){case 1:"unsigned"===t?this.writeOutputValue=(e,t,r)=>e.setUint8(t,O(127.5*(r+1),0,255)):"signed"===t?this.writeOutputValue=(e,t,r)=>{e.setInt8(t,O(Math.round(128*r),-128,127))}:"ulaw"===t?this.writeOutputValue=(e,t,r)=>{const i=O(Math.floor(32767*r),-32768,32767);e.setUint8(t,(e=>{let t=e,r=4096,i=0,o=12,n=0;for(t<0&&(t=-t,i=128),t+=33,t>8191&&(t=8191);(t&r)!==r&&o>=5;)r>>=1,o--;return n=t>>o-4&15,255&~(i|o-5<<4|n)})(i))}:"alaw"===t?this.writeOutputValue=(e,t,r)=>{const i=O(Math.floor(32767*r),-32768,32767);e.setUint8(t,(e=>{let t=2048,r=0,i=11,o=0,n=e;for(n<0&&(n=-n,r=128),n>4095&&(n=4095);(n&t)!==t&&i>=5;)t>>=1,i--;return o=n>>(4===i?1:i-4)&15,85^(r|i-4<<4|o)})(i))}:h(!1);break;case 2:"unsigned"===t?this.writeOutputValue=(e,t,r)=>e.setUint16(t,O(32767.5*(r+1),0,65535),i):"signed"===t?this.writeOutputValue=(e,t,r)=>e.setInt16(t,O(Math.round(32767*r),-32768,32767),i):h(!1);break;case 3:"unsigned"===t?this.writeOutputValue=(e,t,r)=>I(e,t,O(8388607.5*(r+1),0,16777215),i):"signed"===t?this.writeOutputValue=(e,t,r)=>((e,t,r,i)=>{(r=O(r,-8388608,8388607))<0&&(r=r+16777216&16777215),I(e,t,r,i)})(e,t,O(Math.round(8388607*r),-8388608,8388607),i):h(!1);break;case 4:"unsigned"===t?this.writeOutputValue=(e,t,r)=>e.setUint32(t,O(2147483647.5*(r+1),0,4294967295),i):"signed"===t?this.writeOutputValue=(e,t,r)=>e.setInt32(t,O(Math.round(2147483647*r),-2147483648,2147483647),i):"float"===t?this.writeOutputValue=(e,t,r)=>e.setFloat32(t,r,i):h(!1);break;case 8:"float"===t?this.writeOutputValue=(e,t,r)=>e.setFloat64(t,r,i):h(!1);break;default:z(r),h(!1)}}flushAndClose(e){return l(this,null,(function*(){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call((()=>this.customEncoder.flush())),yield this.customEncoderCallSerializer.call((()=>this.customEncoder.close()))):this.encoder&&(e||(yield this.encoder.flush()),"closed"!==this.encoder.state&&this.encoder.close()),e||this.checkForEncoderError()}))}getQueueSize(){var e,t;return this.customEncoder?this.customEncoderQueueSize:this.isPcmEncoder?0:null!=(t=null==(e=this.encoder)?void 0:e.encodeQueueSize)?t:0}checkForEncoderError(){if(this.encoderError)throw this.encoderError.stack=(new Error).stack,this.encoderError}},Nr=()=>{const e=(e,t)=>{t?self.postMessage(e,{transfer:t}):self.postMessage(e)};e({type:"support",supported:"undefined"!=typeof MediaStreamTrackProcessor});const t=new Map,r=new Set;self.addEventListener("message",(i=>{const o=i.data;switch(o.type){case"videoTrack":{const i=new MediaStreamTrackProcessor({track:o.track}),n=new WritableStream({write:t=>{r.has(o.trackId)?t.close():e({type:"videoFrame",trackId:o.trackId,videoFrame:t},[t])}}),a=new AbortController;t.set(o.trackId,a),i.readable.pipeTo(n,{signal:a.signal}).catch((t=>{t instanceof DOMException&&"AbortError"===t.name||e({type:"error",trackId:o.trackId,error:t})}))}break;case"stopTrack":{const i=t.get(o.trackId);i&&(i.abort(),t.delete(o.trackId)),r.add(o.trackId),e({type:"trackStopped",trackId:o.trackId})}break;default:z(o)}}))},Ur=0,Dr=null,Hr=null,Lr=()=>l(null,null,(function*(){return null!==Hr?Hr:(Dr||(()=>{const e=new Blob([`(${Nr.toString()})()`],{type:"application/javascript"}),t=URL.createObjectURL(e);Dr=new Worker(t)})(),new Promise((e=>{h(Dr);const t=r=>{const i=r.data;"support"===i.type&&(Hr=i.supported,Dr.removeEventListener("message",t),e(i.supported))};Dr.addEventListener("message",t)})))})),$r=(e,t)=>{h(Dr),t?Dr.postMessage(e,t):Dr.postMessage(e)},jr=class extends Or{constructor(e){if(super(),this._connectedTrack=null,!$.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${$.join(", ")}.`);this._codec=e}},Qr=["video","audio","subtitle"],qr=e=>{if(!e||"object"!=typeof e)throw new TypeError("metadata must be an object.");if(void 0!==e.languageCode&&(t=e.languageCode,!F.test(t)))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");var t;if(void 0!==e.name&&"string"!=typeof e.name)throw new TypeError("metadata.name, when provided, must be a string.")};return{Output:class{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new M,this._metadataTags={},!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(!(e.format instanceof vr))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof Zt))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,t={}){if(!(e instanceof Fr))throw new TypeError("source must be a VideoSource.");if(qr(t),void 0!==t.rotation&&![0,90,180,270].includes(t.rotation))throw new TypeError(`Invalid video rotation: ${t.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&t.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(void 0!==t.frameRate&&(!Number.isFinite(t.frameRate)||t.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${t.frameRate}. Must be a positive number.`);this._addTrack("video",e,t)}addAudioTrack(e,t={}){if(!(e instanceof Rr))throw new TypeError("source must be an AudioSource.");qr(t),this._addTrack("audio",e,t)}addSubtitleTrack(e,t={}){if(!(e instanceof jr))throw new TypeError("source must be a SubtitleSource.");qr(t),this._addTrack("subtitle",e,t)}setMetadataTags(e){if((e=>{if(!e||"object"!=typeof e)throw new TypeError("tags must be an object.");if(void 0!==e.title&&"string"!=typeof e.title)throw new TypeError("tags.title, when provided, must be a string.");if(void 0!==e.description&&"string"!=typeof e.description)throw new TypeError("tags.description, when provided, must be a string.");if(void 0!==e.artist&&"string"!=typeof e.artist)throw new TypeError("tags.artist, when provided, must be a string.");if(void 0!==e.album&&"string"!=typeof e.album)throw new TypeError("tags.album, when provided, must be a string.");if(void 0!==e.albumArtist&&"string"!=typeof e.albumArtist)throw new TypeError("tags.albumArtist, when provided, must be a string.");if(void 0!==e.trackNumber&&(!Number.isInteger(e.trackNumber)||e.trackNumber<=0))throw new TypeError("tags.trackNumber, when provided, must be a positive integer.");if(void 0!==e.tracksTotal&&(!Number.isInteger(e.tracksTotal)||e.tracksTotal<=0))throw new TypeError("tags.tracksTotal, when provided, must be a positive integer.");if(void 0!==e.discNumber&&(!Number.isInteger(e.discNumber)||e.discNumber<=0))throw new TypeError("tags.discNumber, when provided, must be a positive integer.");if(void 0!==e.discsTotal&&(!Number.isInteger(e.discsTotal)||e.discsTotal<=0))throw new TypeError("tags.discsTotal, when provided, must be a positive integer.");if(void 0!==e.genre&&"string"!=typeof e.genre)throw new TypeError("tags.genre, when provided, must be a string.");if(void 0!==e.date&&(!(e.date instanceof Date)||Number.isNaN(e.date.getTime())))throw new TypeError("tags.date, when provided, must be a valid Date.");if(void 0!==e.lyrics&&"string"!=typeof e.lyrics)throw new TypeError("tags.lyrics, when provided, must be a string.");if(void 0!==e.images){if(!Array.isArray(e.images))throw new TypeError("tags.images, when provided, must be an array.");for(const t of e.images){if(!t||"object"!=typeof t)throw new TypeError("Each image in tags.images must be an object.");if(!(t.data instanceof Uint8Array))throw new TypeError("Each image.data must be a Uint8Array.");if("string"!=typeof t.mimeType)throw new TypeError("Each image.mimeType must be a string.");if(!["coverFront","coverBack","unknown"].includes(t.kind))throw new TypeError("Each image.kind must be 'coverFront', 'coverBack', or 'unknown'.")}}if(void 0!==e.comment&&"string"!=typeof e.comment)throw new TypeError("tags.comment, when provided, must be a string.");if(void 0!==e.raw){if(!e.raw||"object"!=typeof e.raw)throw new TypeError("tags.raw, when provided, must be an object.");for(const t of Object.values(e.raw))if(!(null===t||"string"==typeof t||t instanceof Uint8Array||t instanceof N))throw new TypeError("Each value in tags.raw must be a string, Uint8Array, RichImageData, or null.")}})(e),"pending"!==this.state)throw new Error("Cannot set metadata tags after output has been started or canceled.");this._metadataTags=e}_addTrack(e,t,r){if("pending"!==this.state)throw new Error("Cannot add track after output has been started or canceled.");if(t._connectedTrack)throw new Error("Source is already used for a track.");const i=this.format.getSupportedTrackCounts(),o=this._tracks.reduce(((t,r)=>t+(r.type===e?1:0)),0),n=i[e].max;if(o===n)throw new Error(0===n?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${n} ${e} track${1===n?"":"s"}.`);const a=i.total.max;if(this._tracks.length===a)throw new Error(`${this.format._name} does not support more than ${a} tracks${1===a?"":"s"} in total.`);const s={id:this._tracks.length+1,output:this,type:e,source:t,metadata:r};if("video"===s.type){const e=this.format.getSupportedVideoCodecs();if(0===e.length)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(s.source._codec));if(!e.includes(s.source._codec))throw new Error(`Codec '${s.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${e.map((e=>`'${e}'`)).join(", ")}.`+this.format._codecUnsupportedHint(s.source._codec))}else if("audio"===s.type){const e=this.format.getSupportedAudioCodecs();if(0===e.length)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(s.source._codec));if(!e.includes(s.source._codec))throw new Error(`Codec '${s.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${e.map((e=>`'${e}'`)).join(", ")}.`+this.format._codecUnsupportedHint(s.source._codec))}else if("subtitle"===s.type){const e=this.format.getSupportedSubtitleCodecs();if(0===e.length)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(s.source._codec));if(!e.includes(s.source._codec))throw new Error(`Codec '${s.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${e.map((e=>`'${e}'`)).join(", ")}.`+this.format._codecUnsupportedHint(s.source._codec))}this._tracks.push(s),t._connectedTrack=s}start(){return l(this,null,(function*(){const e=this.format.getSupportedTrackCounts();for(const t of Qr){const r=this._tracks.reduce(((e,r)=>e+(r.type===t?1:0)),0),i=e[t].min;if(r<i)throw new Error(i===e[t].max?`${this.format._name} requires exactly ${i} ${t} track${1===i?"":"s"}.`:`${this.format._name} requires at least ${i} ${t} track${1===i?"":"s"}.`)}const t=e.total.min;if(this._tracks.length<t)throw new Error(t===e.total.max?`${this.format._name} requires exactly ${t} track${1===t?"":"s"}.`:`${this.format._name} requires at least ${t} track${1===t?"":"s"}.`);if("canceled"===this.state)throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(()=>l(this,null,(function*(){this.state="started",this._writer.start();const e=yield this._mutex.acquire();yield this._muxer.start();const t=this._tracks.map((e=>e.source._start()));yield Promise.all(t),e()})))()}))}getMimeType(){return this._muxer.getMimeType()}cancel(){return l(this,null,(function*(){return this._cancelPromise?(console.warn("Output has already been canceled."),this._cancelPromise):"finalizing"!==this.state&&"finalized"!==this.state?this._cancelPromise=(()=>l(this,null,(function*(){this.state="canceled";const e=yield this._mutex.acquire(),t=this._tracks.map((e=>e.source._flushOrWaitForOngoingClose(!0)));yield Promise.all(t),yield this._writer.close(),e()})))():void console.warn("Output has already been finalized.")}))}finalize(){return l(this,null,(function*(){if("pending"===this.state)throw new Error("Cannot finalize before starting.");if("canceled"===this.state)throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(()=>l(this,null,(function*(){this.state="finalizing";const e=yield this._mutex.acquire(),t=this._tracks.map((e=>e.source._flushOrWaitForOngoingClose(!1)));yield Promise.all(t),yield this._muxer.finalize(),yield this._writer.flush(),yield this._writer.finalize(),this.state="finalized",e()})))()}))}},NullTarget:class extends Zt{_createWriter(){return new Jt(this)}},Mp4OutputFormat:Tr,MediaStreamAudioTrackSource:class extends Rr{get errorPromise(){return this._errorPromiseAccessed=!0,this._promiseWithResolvers.promise}constructor(e,t){if(!(e instanceof MediaStreamTrack)||"audio"!==e.kind)throw new TypeError("track must be an audio MediaStreamTrack.");(e=>{if(!e||"object"!=typeof e)throw new TypeError("Encoding config must be an object.");if(!L.includes(e.codec))throw new TypeError(`Invalid audio codec '${e.codec}'. Must be one of: ${L.join(", ")}.`);if(void 0===e.bitrate&&(!D.includes(e.codec)||"flac"===e.codec))throw new TypeError("config.bitrate must be provided for compressed audio codecs.");if(void 0!==e.bitrate&&!(e.bitrate instanceof Br)&&(!Number.isInteger(e.bitrate)||e.bitrate<=0))throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");if(void 0!==e.onEncodedPacket&&"function"!=typeof e.onEncodedPacket)throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(void 0!==e.onEncoderConfig&&"function"!=typeof e.onEncoderConfig)throw new TypeError("config.onEncoderConfig, when provided, must be a function.");xr(e.codec,e)})(t),super(t.codec),this._abortController=null,this._audioContext=null,this._scriptProcessorNode=null,this._promiseWithResolvers=A(),this._errorPromiseAccessed=!1,this._encoder=new Vr(this,t),this._track=e}_start(){return l(this,null,(function*(){if(this._errorPromiseAccessed||console.warn("Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal errors get bubbled up properly."),this._abortController=new AbortController,"undefined"!=typeof MediaStreamTrackProcessor){let e=null;const t=new MediaStreamTrackProcessor({track:this._track}),r=new WritableStream({write:t=>{if(null===e){e=t.timestamp/1e6;const r=this._connectedTrack.output._muxer;null===r.firstMediaStreamTimestamp?(r.firstMediaStreamTimestamp=performance.now()/1e3,this._timestampOffset=-e):this._timestampOffset=performance.now()/1e3-r.firstMediaStreamTimestamp-e}this._encoder.getQueueSize()>=4?t.close():this._encoder.add(new fr(t),!0).catch((e=>{var t;null==(t=this._abortController)||t.abort(),this._promiseWithResolvers.reject(e)}))}});t.readable.pipeTo(r,{signal:this._abortController.signal}).catch((e=>{e instanceof DOMException&&"AbortError"===e.name||this._promiseWithResolvers.reject(e)}))}else{const e=window.AudioContext||window.webkitAudioContext;this._audioContext=new e({sampleRate:this._track.getSettings().sampleRate});const t=this._audioContext.createMediaStreamSource(new MediaStream([this._track]));this._scriptProcessorNode=this._audioContext.createScriptProcessor(4096),"suspended"===this._audioContext.state&&(yield this._audioContext.resume()),t.connect(this._scriptProcessorNode),this._scriptProcessorNode.connect(this._audioContext.destination);let r=!1,i=0;this._scriptProcessorNode.onaudioprocess=e=>{const t=fr._fromAudioBuffer(e.inputBuffer,i);i+=e.inputBuffer.duration;for(const e of t){if(!r){r=!0;const e=this._connectedTrack.output._muxer;null===e.firstMediaStreamTimestamp?e.firstMediaStreamTimestamp=performance.now()/1e3:this._timestampOffset=performance.now()/1e3-e.firstMediaStreamTimestamp}this._encoder.getQueueSize()>=4?e.close():this._encoder.add(e,!0).catch((e=>{this._audioContext.suspend(),this._promiseWithResolvers.reject(e)}))}}}}))}_flushAndClose(e){return l(this,null,(function*(){this._abortController&&(this._abortController.abort(),this._abortController=null),this._audioContext&&(h(this._scriptProcessorNode),this._scriptProcessorNode.disconnect(),yield this._audioContext.suspend()),yield this._encoder.flushAndClose(e)}))}},MediaStreamVideoTrackSource:class extends Fr{get errorPromise(){return this._errorPromiseAccessed=!0,this._promiseWithResolvers.promise}constructor(e,t){if(!(e instanceof MediaStreamTrack)||"video"!==e.kind)throw new TypeError("track must be a video MediaStreamTrack.");(e=>{if(!e||"object"!=typeof e)throw new TypeError("Encoding config must be an object.");if(!U.includes(e.codec))throw new TypeError(`Invalid video codec '${e.codec}'. Must be one of: ${U.join(", ")}.`);if(!(e.bitrate instanceof Br)&&(!Number.isInteger(e.bitrate)||e.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(void 0!==e.keyFrameInterval&&(!Number.isFinite(e.keyFrameInterval)||e.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(void 0!==e.sizeChangeBehavior&&!["deny","passThrough","fill","contain","cover"].includes(e.sizeChangeBehavior))throw new TypeError("config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'.");if(void 0!==e.onEncodedPacket&&"function"!=typeof e.onEncodedPacket)throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(void 0!==e.onEncoderConfig&&"function"!=typeof e.onEncoderConfig)throw new TypeError("config.onEncoderConfig, when provided, must be a function.");Er(e.codec,e)})(t),super((t=d(c({},t),{latencyMode:"realtime"})).codec),this._abortController=null,this._workerTrackId=null,this._workerListener=null,this._promiseWithResolvers=A(),this._errorPromiseAccessed=!1,this._encoder=new Wr(this,t),this._track=e}_start(){return l(this,null,(function*(){this._errorPromiseAccessed||console.warn("Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal errors get bubbled up properly."),this._abortController=new AbortController;let e=null,t=!1;const r=r=>{if(t)r.close();else{if(null===e){e=r.timestamp/1e6;const t=this._connectedTrack.output._muxer;null===t.firstMediaStreamTimestamp?(t.firstMediaStreamTimestamp=performance.now()/1e3,this._timestampOffset=-e):this._timestampOffset=performance.now()/1e3-t.firstMediaStreamTimestamp-e}this._encoder.getQueueSize()>=4?r.close():this._encoder.add(new dr(r),!0).catch((e=>{var r;t=!0,null==(r=this._abortController)||r.abort(),this._promiseWithResolvers.reject(e),null!==this._workerTrackId&&$r({type:"stopTrack",trackId:this._workerTrackId})}))}};if("undefined"!=typeof MediaStreamTrackProcessor){const e=new MediaStreamTrackProcessor({track:this._track}),t=new WritableStream({write:r});e.readable.pipeTo(t,{signal:this._abortController.signal}).catch((e=>{e instanceof DOMException&&"AbortError"===e.name||this._promiseWithResolvers.reject(e)}))}else{if(!(yield Lr()))throw new Error("MediaStreamTrackProcessor is required but not supported by this browser.");this._workerTrackId=Ur++,$r({type:"videoTrack",trackId:this._workerTrackId,track:this._track},[this._track]),this._workerListener=e=>{const t=e.data;"videoFrame"===t.type&&t.trackId===this._workerTrackId?r(t.videoFrame):"error"===t.type&&t.trackId===this._workerTrackId&&this._promiseWithResolvers.reject(t.error)},Dr.addEventListener("message",this._workerListener)}}))}_flushAndClose(e){return l(this,null,(function*(){this._abortController&&(this._abortController.abort(),this._abortController=null),null!==this._workerTrackId&&(h(this._workerListener),$r({type:"stopTrack",trackId:this._workerTrackId}),yield new Promise((e=>{const t=r=>{const i=r.data;"trackStopped"===i.type&&i.trackId===this._workerTrackId&&(h(this._workerListener),Dr.removeEventListener("message",this._workerListener),Dr.removeEventListener("message",t),e())};Dr.addEventListener("message",t)}))),yield this._encoder.flushAndClose(e)}))}},getFirstEncodableVideoCodec:(e,t)=>l(null,null,(function*(){for(const r of e)if(yield zr(r,t))return r;return null})),getFirstEncodableAudioCodec:(e,t)=>l(null,null,(function*(){for(const r of e)if(yield Ir(r,t))return r;return null})),QUALITY_LOW:Pr,QUALITY_MEDIUM:Mr,QUALITY_HIGH:Ar}})();
/*! Bundled license information:

mediabunny/dist/modules/src/misc.js:
mediabunny/dist/modules/src/tags.js:
mediabunny/dist/modules/src/codec.js:
mediabunny/dist/modules/src/muxer.js:
mediabunny/dist/modules/src/subtitles.js:
mediabunny/dist/modules/src/codec-data.js:
mediabunny/dist/modules/src/isobmff/isobmff-boxes.js:
mediabunny/dist/modules/src/writer.js:
mediabunny/dist/modules/src/target.js:
mediabunny/dist/modules/src/isobmff/isobmff-misc.js:
mediabunny/dist/modules/src/isobmff/isobmff-reader.js:
mediabunny/dist/modules/src/isobmff/isobmff-muxer.js:
mediabunny/dist/modules/src/custom-coder.js:
mediabunny/dist/modules/src/packet.js:
mediabunny/dist/modules/src/pcm.js:
mediabunny/dist/modules/src/sample.js:
mediabunny/dist/modules/src/output-format.js:
mediabunny/dist/modules/src/encode.js:
mediabunny/dist/modules/src/media-source.js:
mediabunny/dist/modules/src/output.js:
mediabunny/dist/modules/src/index.js:
  (*!
   * Copyright (c) 2025-present, Vanilagy and contributors
   *
   * This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at https://mozilla.org/MPL/2.0/.
   *)
*/